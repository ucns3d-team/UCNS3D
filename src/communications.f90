MODULE COMMUNICATIONS
!> @brief
!> This module includes all the subroutines related to the MPI communications for various procedures
!> including exchange of halo cells from stencils, direct-side neighbours, and the boundary extrapolated
!> values for the conserved variables and their gradients at each surface/edge Gaussian quadrature point

USE MPIINFO
USE DECLARATION
USE TRANSFORM
IMPLICIT NONE

contains

SUBROUTINE RENUMBER_NEIGHBOURS(N,IELEM,XMPIE,XMPIELRANK,IEXCHANGER,IEXCHANGES)
!> @brief
!> This subroutine renumbers the neighbours indexing for cross referencing between different cpus
!> It is a process that is performed once the beginning of each run

IMPLICIT NONE
TYPE(ELEMENT_NUMBER),ALLOCATABLE,DIMENSION(:,:),INTENT(INOUT)::IELEM
INTEGER,INTENT(IN)::N
INTEGER,ALLOCATABLE,DIMENSION(:),INTENT(IN)::XMPIE
INTEGER,ALLOCATABLE,DIMENSION(:),INTENT(IN)::XMPIELRANK
TYPE(EXCHANGE),ALLOCATABLE,DIMENSION(:),INTENT(INOUT)::IEXCHANGER,IEXCHANGES
INTEGER::I,J,K,L,M,E,KMAXE,INEEDT,TNEEDT,IX1,IX2,CNBT,IVT,itax,inum_points,inn,jjj,kk,itogg,ifdn,ifdn2,ifdn3,iii,iouf,JJ1
integer::c_n1,c_n2,c_n3,c_n4,d_n1,d_n2,d_n3,d_n4,kvf,itor4
INEEDT=IEXCHANGER(1)%TOT
TNEEDT=IEXCHANGES(1)%TOT
KMAXE=XMPIELRANK(N)
DO I=1,KMAXE
	if (ielem(n,i)%interior.eq.1)then
	allocate(ielem(n,i)%ineighn(ielem(n,i)%ifca))
	allocate(ielem(n,i)%ineighb(ielem(n,i)%ifca))
	allocate(ielem(n,i)%ineigh(ielem(n,i)%ifca))
	ielem(n,i)%ineigh(:)=0;ielem(n,i)%ineighn(:)=0;ielem(n,i)%ineighb(:)=n
	else
	allocate(ielem(n,i)%ineighn(ielem(n,i)%ifca))
	allocate(ielem(n,i)%ineigh(ielem(n,i)%ifca))
	ielem(n,i)%ineighn(:)=0;ielem(n,i)%ineigh(:)=0;
	end if
END DO


if (dimensiona.eq.3)then
 ifdn=4
else
  ifdn=2
end if


DO I=1,KMAXE
      if (ielem(n,i)%interior.eq.0)then
	DO J=1,IELEM(N,I)%IFCA
		IF (IELEM(N,I)%INEIGHG(J).GT.0)THEN
			IF (XMPIE(IELEM(N,I)%INEIGHG(J)).EQ.N)THEN
			
			K=xmpil(IELEM(N,I)%INEIGHG(J))
			do ivt=1,ielem(n,K)%ifca
							IF (IELEM(N,K)%INEIGHG(IVT).EQ.IELEM(N,I)%IHEXGL) THEN
							IELEM(N,I)%INEIGH(J)=xmpil(IELEM(N,I)%INEIGHG(J))
							IELEM(N,I)%INEIGHN(J)=IVT
							go to 101
							END IF
			end do
			END IF
		END IF
	101 continue
		
	END DO
      end if
END DO






do i=1,kmaxe
if (ielem(n,i)%interior.eq.1)then
DO J=1,IELEM(N,I)%IFCA
itax=0
	IF ((IELEM(N,I)%INEIGHG(J).GT.0))then
	    if(XMPIE(IELEM(N,I)%INEIGHG(J)).NE.N)THEN
	      IELEM(N,I)%INEIGHB(J)=XMPIE(IELEM(N,I)%INEIGHG(J))
	     
	    eLSE
			      
				    K=xmpil(IELEM(N,I)%INEIGHG(J))
    ! 				  
				    do ivt=1,ielem(n,K)%ifca
							  IF (IELEM(N,K)%INEIGHG(IVT).EQ.IELEM(N,i)%Ihexgl) THEN
    ! 							
							    IELEM(N,I)%INEIGH(J)=k
							    IELEM(N,I)%INEIGHN(J)=IVT
							    IELEM(N,I)%INEIGHb(J)=n
							    END IF
			    
				    end do  

	    end if
	end if
end do
end if
end do












JJ1=0
DO K=1,INEEDT
DO IX1=1,TNEEDT
DO E=1,IEXCHANGER(K)%MUCHINEED(1)
DO IX2=1,IEXCHANGES(IX1)%MUCHTHEYNEED(1)
IF ((IEXCHANGES1(IX1)%WHATTHEYNEED(IX2).EQ.IEXCHANGER1(K)%SIDEINEEDN(E)).AND.&
(IEXCHANGES1(IX1)%SIDETHEYNEEDN(IX2).EQ.IEXCHANGER1(K)%WHATINEED(E)))then

I=xmpil(IEXCHANGER1(K)%sideineedn(E))
! do i=1,kmaxe
  if (ielem(n,i)%interior.eq.1)then
    DO J=1,IELEM(N,I)%IFCA
	  if (ielem(n,i)%ineighb(j).ne.n)then
	  
	    if (ielem(n,i)%ibounds(J).gt.0)then
		if (ibound(n,ielem(n,i)%ibounds(j))%icode.eq.5)then
		    if (dimensiona.eq.3)then
			IF ( IELEM(N,i)%TYPEs_FACES(J).EQ.5)THEN
			    INUM_POINTS=QP_QUAD_n
			  ELSE
			    INUM_POINTS=QP_TRIANGLE_n
			 End if
		    else
			    INUM_POINTS=QP_LINE_n
		    END IF
		    
		   
		    



IF ((IEXCHANGER(K)%PROCID.EQ.IELEM(N,I)%ineighb(J)).and. (IEXCHANGES(IX1)%PROCID.EQ.IELEM(N,I)%ineighb(J)))THEN
if ((IEXCHANGES1(IX1)%SIDETHEYNEEDN(IX2).EQ.IELEM(N,I)%ineighg(J)).AND.&
(IELEM(N,I)%ineighg(J).EQ.IEXCHANGER1(K)%WHATINEED(E)))then
 do inn=1,inum_points
IF ((IEXCHANGES1(IX1)%WHATTHEYNEED(IX2).EQ.IELEM(N,I)%IHEXGL).and.(IEXCHANGES1(IX1)%QTHEYNEED(IX2).EQ.IEXCHANGER1(K)%QINEED(E)).and.(inn.eq.IEXCHANGES1(IX1)%QTHEYNEED(IX2)))then
IELEM(N,I)%Q_FACE(J)%Q_MAPL(INN)=E
IELEM(N,I)%INEIGHN(J)=K
IEXCHANGEs(ix1)%SIDEtheyNEED(ix2)=j

JJ1=JJ1+1
END IF
end do
end if
end if



      

      
end if      
else

if (dimensiona.eq.3)then
			IF ( IELEM(N,i)%TYPEs_FACES(J).EQ.5)THEN
			    INUM_POINTS=QP_QUAD_n
			  ELSE
			    INUM_POINTS=QP_TRIANGLE_n
			 End if
		    else
			    INUM_POINTS=QP_LINE_n
		    END IF
		    
		    



IF ((IEXCHANGER(K)%PROCID.EQ.IELEM(N,I)%INEIGHB(J)).and. (IEXCHANGES(IX1)%PROCID.EQ.IELEM(N,I)%INEIGHB(J)))THEN
if ((IEXCHANGES1(IX1)%SIDETHEYNEEDN(IX2).EQ.IELEM(N,I)%INEIGHG(J)).AND.&
(IELEM(N,I)%INEIGHG(J).EQ.IEXCHANGER1(K)%WHATINEED(E)))then
do inn=1,inum_points
IF ((IEXCHANGES1(IX1)%WHATTHEYNEED(IX2).EQ.IELEM(N,I)%IHEXGL).and.(IEXCHANGES1(IX1)%QTHEYNEED(IX2).EQ.IEXCHANGER1(K)%QINEED(E)).and.(inn.eq.IEXCHANGES1(IX1)%QTHEYNEED(IX2)))then
IELEM(N,I)%Q_FACE(J)%Q_MAPL(INN)=E
IELEM(N,I)%INEIGHN(J)=K
IEXCHANGES(IX1)%SIDETHEYNEED(IX2)=J

END IF
end do
end if
end if


end if
end if


end do
end if


! end do
end if
end do
end do
end do
end do





END SUBROUTINE RENUMBER_NEIGHBOURS



SUBROUTINE SOLEX_ALLOC(N)
!> @brief
!> This subroutine allocates the memory for the halo cells of the direct side neighbours only
!> and is therefore used for lower-order schemes 
IMPLICIT NONE
INTEGER,INTENT(IN)::N
INTEGER::I,J,K,L,M,E,KMAXE,INEEDT,TNEEDT,ICPUID
INEEDT=IEXCHANGER(1)%TOT
TNEEDT=IEXCHANGES(1)%TOT
ALLOCATE(SOLCHANGER(INEEDT))
ALLOCATE(SOLCHANGES(TNEEDT))
! SOLCHANGER(:)=0
! SOLCHANGES(:)=0
DO I=1,INEEDT
	SOLCHANGER(I)%PROCID=IEXCHANGER(I)%PROCID
	ALLOCATE (SOLCHANGER(I)%CENTRES(IEXCHANGER(I)%MUCHINEED(1),dims))
	
	SOLCHANGER(I)%CENTRES(:,:)=0.d0
	
	ALLOCATE (SOLCHANGER(I)%SOL(IEXCHANGER(I)%MUCHINEED(1),nof_variables+turbulenceequations+passivescalar))
	SOLCHANGER(I)%SOL(:,:)=0.0d0
END DO
DO I=1,TNEEDT
	SOLCHANGES(I)%PROCID=IEXCHANGES(I)%PROCID
	ALLOCATE (SOLCHANGES(I)%CENTRES(IEXCHANGES(I)%MUCHTHEYNEED(1),dims))
	
	SOLCHANGES(I)%CENTRES(:,:)=0.0d0
	
	ALLOCATE (SOLCHANGES(I)%SOL(IEXCHANGES(I)%MUCHTHEYNEED(1),nof_variables+turbulenceequations+passivescalar))
	SOLCHANGES(I)%SOL(:,:)=0.0d0
END DO

!-------------------FOR DEBUGGING ONLY -----------------------------------------!

!-------------------FOR DEBUGGING ONLY -----------------------------------------!
DO I=1,TNEEDT
	DO K=1,IEXCHANGES(I)%MUCHTHEYNEED(1)
		j=IEXCHANGES(I)%LOCALREF(K)
		    if (dimensiona.eq.3)then
		    CALL COMPUTE_CENTRE3d(N,j)
		    else
		     CALL COMPUTE_CENTRE2d(N,j)
		    end if
	SOLCHANGES(I)%CENTRES(K,1:dims)=cords(1:dims)
	END DO
END DO
CALL MPI_BARRIER(MPI_COMM_WORLD,IERROR)
ICPUID=N
DO I=1,INEEDT
		DO K=1,TNEEDT
		IF (SOLCHANGER(I)%PROCID.EQ.SOLCHANGES(K)%PROCID)THEN
		CALL MPI_SENDRECV(SOLCHANGES(K)%CENTRES(1:IEXCHANGES(K)%MUCHTHEYNEED(1),1:dims),&
IEXCHANGES(K)%MUCHTHEYNEED(1)*dims,MPI_DOUBLE_PRECISION,SOLCHANGER(I)%PROCID,&
		SOLCHANGES(K)%PROCID,SOLCHANGER(I)%CENTRES(1:IEXCHANGER(I)%MUCHINEED(1),1:dims),&
IEXCHANGER(I)%MUCHINEED(1)*dims,MPI_DOUBLE_PRECISION,&
		SOLCHANGER(I)%PROCID,ICPUID,MPI_COMM_WORLD,STATUS,IERROR)
		END IF
		END DO
END DO

END SUBROUTINE SOLEX_ALLOC




SUBROUTINE ESTABEXHANGE(N,IELEM,IMAXE,XMPIE,XMPIN,XMPIELRANK,ILOCALSTENCIL,IEXCHANGER,&
IEXCHANGES,IRECEXR,IRECEXS,NUMNEIGHBOURS,ISCHEME,ISIZE,IPERIODICITY,TYPESTEN,XMPIL)
!> @brief
!> This subroutine is establishing the communication patterns for all the MPI processes and in particular for
!> the halo cells of the reconstruction stencils and it must be noted that each cell can have a different number of stencils
!> of different size

	IMPLICIT NONE
	TYPE(ELEMENT_NUMBER),ALLOCATABLE,DIMENSION(:,:),INTENT(INOUT)::IELEM
	INTEGER,INTENT(IN)::N,IMAXE,ISIZE,IPERIODICITY,TYPESTEN
	INTEGER,ALLOCATABLE,DIMENSION(:),INTENT(IN)::XMPIE,XMPIN,XMPIL
	INTEGER,ALLOCATABLE,DIMENSION(:),INTENT(IN)::XMPIELRANK
	TYPE(EXCHANGE),ALLOCATABLE,DIMENSION(:),INTENT(INOUT)::IEXCHANGES
	TYPE(EXCHANGE),ALLOCATABLE,DIMENSION(:),INTENT(INOUT)::IEXCHANGER
	INTEGER,ALLOCATABLE,DIMENSION(:,:,:,:),INTENT(IN)::ILOCALSTENCIL
	INTEGER,INTENT(IN)::NUMNEIGHBOURS,ISCHEME
	TYPE(RECEX),ALLOCATABLE,DIMENSION(:),INTENT(INOUT)::IRECEXR		!RECEIVE ELEMENTS DUE TO STENCILS
	TYPE(RECEX),ALLOCATABLE,DIMENSION(:),INTENT(INOUT)::IRECEXS	
	INTEGER,ALLOCATABLE,DIMENSION(:)::TOTSTENC,TOTSTENC2
	INTEGER,ALLOCATABLE,DIMENSION(:)::STENRED
	INTEGER,ALLOCATABLE,DIMENSION(:)::STENREDPROC
	TYPE LISTSTENCILS
	INTEGER::PROCID
	INTEGER,ALLOCATABLE,DIMENSION(:)::LISTSARRAY
	END TYPE LISTSTENCILS
	INTEGER,DIMENSION(0:ISIZE-1)::SENDWH
	INTEGER,DIMENSION(0:ISIZE-1)::LISTOFPR
	INTEGER,DIMENSION(0:ISIZE-1)::SENDSTWH
	TYPE:: LISTGOG
	INTEGER::PROCID,IMUCH,IAVC,IAVT
	INTEGER,ALLOCATABLE,DIMENSION(:)::GLOBARRAY
	integer,allocatable,dimension(:,:)::nodex
	END TYPE LISTGOG
	TYPE(LISTSTENCILS),ALLOCATABLE,DIMENSION(:)::ILISTSTEN
	TYPE(LISTGOG),ALLOCATABLE,DIMENSION(:)::ILISTGOG,ILISTSIDE,ILISTGLO,ILISTQ
	INTEGER::HOWMANY,ITEE,SOURCE,TAG,CPUIDREC,ICPUID,IXFLAG,ITEEDUM,IAVC,IAVT
	INTEGER,DIMENSION(1:1)::RUMTS,SUMTS
	REAL,DIMENSION(1:1)::DUMTS
	INTEGER::STENCOUNTER,STENCOUNTER2,STENSAME,IIFLAG,TEMPSTEN2,IIFLAG2,KXK,IX,ICX,ICF,ifdn,ifdn2
	INTEGER,DIMENSION(0:ISIZE-1)::IHMSTE
	INTEGER::I,J,JI,K,LM,KMAXN,KK,KMAXE,IAA,L,INGT,IK,TEMPINT,TEMP2,ITARGET,ISTY5,i86,I87,I65,INUM_POINTS,IIN
	KMAXE=XMPIELRANK(N)
	LISTOFPR(:)=0
	I65=0
	if (dimensiona.eq.3)then
	ifdn=4
	
	else

	ifdn=2
	end if
	DO K=1,KMAXE
	      IF (IELEM(N,K)%INTERIOR.EQ.1)THEN
	      ALLOCATE(IELEM(N,K)%Q_FACE(IELEM(N,K)%IFCA))
	      DO L=1,IELEM(N,K)%IFCA
					    if (dimensiona.eq.3)then
					    IF ( IELEM(N,K)%TYPEs_FACES(L).EQ.5)THEN
					    INUM_POINTS=QP_QUAD_n
					    ELSE
					    INUM_POINTS=QP_TRIANGLE_n
					    End if
					    else
					    INUM_POINTS=QP_LINE_n
					    END IF
	      ALLOCATE(IELEM(N,K)%Q_FACE(L)%Q_MAPL(INUM_POINTS))
	      IELEM(N,K)%Q_FACE(L)%Q_MAPL(:)=0
	      END DO
	      END IF
	END DO



	DO K=1,KMAXE
		IF (IELEM(N,K)%INTERIOR.EQ.1)THEN
			DO L=1,IELEM(N,K)%IFCA
				    IF (IELEM(N,K)%INEIGHG(L).GT.0)THEN
					    IF (XMPIE(IELEM(N,K)%INEIGHG(L)).NE.N)THEN
					    if (dimensiona.eq.3)then
					    IF ( IELEM(N,K)%TYPEs_FACES(L).EQ.5)THEN
					    INUM_POINTS=QP_QUAD_n
					    ELSE
					    INUM_POINTS=QP_TRIANGLE_n
					    End if
					    else
					    INUM_POINTS=QP_LINE_n
					    END IF
					    
					   
					      
					    LISTOFPR(XMPIE(IELEM(N,K)%INEIGHG(L)))=LISTOFPR(XMPIE(IELEM(N,K)%INEIGHG(L)))+INUM_POINTS
					    END IF
				    END IF
			  END DO
		
		END IF
	END DO

	HOWMANY=0
	DO K=0,ISIZE-1
		IF (LISTOFPR(K).GT.0)THEN
		HOWMANY=HOWMANY+1
		END IF
	END DO
	ALLOCATE (ILISTGOG(HOWMANY))
	ALLOCATE (ILISTSIDE(HOWMANY))
	ALLOCATE (ILISTQ(HOWMANY))
	ALLOCATE (ILISTGLO(HOWMANY))
	
! 	ILISTGOG(:)=0
! 	ILISTSIDE(:)=0
	KK=0
	DO K=0,ISIZE-1
		IF (LISTOFPR(K).GT.0)THEN
		KK=KK+1
		ILISTGOG(KK)%PROCID=K
		ILISTGOG(KK)%IMUCH=LISTOFPR(K)
		ILISTSIDE(KK)%PROCID=K
		ILISTSIDE(KK)%IMUCH=LISTOFPR(K)
		ILISTQ(KK)%PROCID=K
		ILISTQ(KK)%IMUCH=LISTOFPR(K)
		ALLOCATE(ILISTGOG(KK)%GLOBARRAY(LISTOFPR(K)))
		ALLOCATE(ILISTSIDE(KK)%GLOBARRAY(LISTOFPR(K)))
		ALLOCATE(ILISTSIDE(KK)%nodex(LISTOFPR(K),ifdn))
		ALLOCATE(ILISTGLO(KK)%GLOBARRAY(LISTOFPR(K)))
		ALLOCATE(ILISTQ(KK)%GLOBARRAY(LISTOFPR(K)))
		ILISTGOG(KK)%GLOBARRAY(:)=0
		ILISTSIDE(KK)%GLOBARRAY(:)=0;ILISTSIDE(KK)%nodex(:,:)=0
		ILISTGLO(KK)%GLOBARRAY(:)=0
		ILISTQ(KK)%GLOBARRAY(:)=0
		END IF
	END DO
	KK=0
	DO INGT=0,ISIZE-1
		IF (LISTOFPR(INGT).GT.0)THEN
! 		
		KK=KK+1
		IAA=0
		DO K=1,KMAXE
		      IF (IELEM(N,K)%INTERIOR.EQ.1)THEN
			DO L=1,IELEM(N,K)%IFCA
				    IF (IELEM(N,K)%INEIGHG(L).GT.0)THEN
					    IF (XMPIE(IELEM(N,K)%INEIGHG(L)).NE.N)THEN
						IF (XMPIE(IELEM(N,K)%INEIGHG(L)).EQ.ILISTGOG(KK)%PROCID)THEN
						     if (dimensiona.eq.3)then
					    IF ( IELEM(N,K)%TYPEs_FACES(L).EQ.5)THEN
					    INUM_POINTS=QP_QUAD_n; ifdn2=4
					    ELSE
					    INUM_POINTS=QP_TRIANGLE_n ; ifdn2=3
					    End if
					    else
					    INUM_POINTS=QP_LINE_n; ifdn2=2
					    END IF
						 
							    DO IIN=IAA+1,IAA+INUM_POINTS
							    ILISTGOG(KK)%GLOBARRAY(IIN)=(IELEM(N,K)%INEIGHG(L))
							    ILISTGLO(KK)%GLOBARRAY(IIN)=(IELEM(N,K)%IHEXGL)
							    ILISTSIDE(KK)%GLOBARRAY(IIN)=L
							    ILISTQ(KK)%GLOBARRAY(IIN)=IIN-IAA
							    ILISTSIDE(KK)%nodex(iin,1:ifdn2)=ielem(n,k)%nodes_faces(l,1:ifdn2)
							    
							    END DO
							    IAA=IAA+INUM_POINTS
						      
						  END IF
					    END IF
				      END IF
			END DO
		      END IF
		END DO

	      END IF
	  END DO
	      


	SENDWH(:)=0	
	ALLOCATE (IEXCHANGER(HOWMANY))
	ALLOCATE (IEXCHANGER1(HOWMANY))
! 	IEXCHANGER(:)=0
	IEXCHANGER(:)%TOT=HOWMANY
	IEXCHANGER1(:)%TOT=HOWMANY

	KK=0
	DO K=0,ISIZE-1
		IF (LISTOFPR(K).GT.0)THEN
		KK=KK+1
		IEXCHANGER(KK)%PROCID=K
		END IF
	END DO
	
	DO I=1,HOWMANY
		IF (IEXCHANGER(I)%PROCID.NE.N)THEN
		ALLOCATE(IEXCHANGER(I)%MUCHINEED(1))
		IEXCHANGER(I)%MUCHINEED(:)=0
		IEXCHANGER(I)%MUCHINEED(1)=LISTOFPR(IEXCHANGER(I)%PROCID)
		ALLOCATE(IEXCHANGER1(I)%WHATINEED(IEXCHANGER(I)%MUCHINEED(1)))	!ELEMENT NUMBER GLOBAL
		ALLOCATE(IEXCHANGER1(I)%LOCALREF(IEXCHANGER(I)%MUCHINEED(1)))
		ALLOCATE(IEXCHANGER1(I)%SIDEINEED(IEXCHANGER(I)%MUCHINEED(1)))
		ALLOCATE(IEXCHANGER1(I)%nodex(IEXCHANGER(I)%MUCHINEED(1),ifdn))
		ALLOCATE(IEXCHANGER1(I)%QINEED(IEXCHANGER(I)%MUCHINEED(1)))
		ALLOCATE(IEXCHANGER1(I)%SIDEINEEDN(IEXCHANGER(I)%MUCHINEED(1)))
! 		ALLOCATE(IEXCHANGER1(I)%QINEED(IEXCHANGER(I)%MUCHINEED(1)))
		IEXCHANGER1(I)%WHATINEED(:)=0	!ELEMENT NUMBER GLOBAL
		IEXCHANGER1(I)%LOCALREF(:)=0
		IEXCHANGER1(I)%SIDEINEED(:)=0;IEXCHANGER1(I)%nodex(:,:)=0
		IEXCHANGER1(I)%SIDEINEEDN(:)=0
 		IEXCHANGER1(I)%QINEED(:)=0
		
		END IF
	END DO
	TEMPINT=0
! 	
	DO I=1,HOWMANY
		IF (IEXCHANGER(I)%PROCID.NE.N)THEN
		TEMPINT=TEMPINT+1
		IF (IEXCHANGER(I)%PROCID.EQ.ILISTGOG(TEMPINT)%PROCID)THEN
		IEXCHANGER1(I)%WHATINEED(:)=ILISTGOG(TEMPINT)%GLOBARRAY(:)
		IEXCHANGER1(I)%SIDEINEEDN(:)=ILISTGLO(TEMPINT)%GLOBARRAY(:)
		IEXCHANGER1(I)%nodex(1:IEXCHANGER(I)%MUCHINEED(1),1:ifdn)=ILISTside(TEMPINT)%nodex(1:IEXCHANGER(I)%MUCHINEED(1),1:ifdn)
		IEXCHANGER1(I)%QINEED(1:IEXCHANGER(I)%MUCHINEED(1))=ILISTq(TEMPINT)%GLOBARRAY(1:IEXCHANGER(I)%MUCHINEED(1))


		
		
		END IF
		END IF
	END DO
	DEALLOCATE(ILISTGOG)
	CALL MPI_BARRIER(MPI_COMM_WORLD,IERROR)
	ICPUID=N
	DO I=1,HOWMANY
		IF (IEXCHANGER(I)%PROCID.NE.N)THEN
		CALL MPI_SENDRECV(IEXCHANGER(I)%MUCHINEED(1),1,MPI_INTEGER,IEXCHANGER(I)%PROCID,IEXCHANGER(I)%PROCID,&
		ITEE,1,MPI_INTEGER,IEXCHANGER(I)%PROCID,ICPUID,MPI_COMM_WORLD,STATUS,IERROR)
		SENDWH(IEXCHANGER(I)%PROCID)=ITEE
		END IF
	END DO
	CALL MPI_BARRIER(MPI_COMM_WORLD,IERROR)
	TEMP2=0
	DO I=0,ISIZE-1
		IF (SENDWH(I).GT.0)THEN
		TEMP2=TEMP2+1
		END IF
	END DO
	
! 
	ALLOCATE (IEXCHANGES(TEMP2))
	ALLOCATE (IEXCHANGES1(TEMP2))
! 	IEXCHANGES(:)=0
	IEXCHANGES(:)%TOT=TEMP2
	KK=0
	DO I=0,ISIZE-1
		IF (SENDWH(I).GT.0)THEN
		KK=KK+1
		IEXCHANGES(KK)%PROCID=I
		ALLOCATE(IEXCHANGES(KK)%MUCHTHEYNEED(1))
		IEXCHANGES(KK)%MUCHTHEYNEED(:)=0
		IEXCHANGES(KK)%MUCHTHEYNEED(1)=SENDWH(I)
		ALLOCATE(IEXCHANGES1(KK)%WHATTHEYNEED(IEXCHANGES(KK)%MUCHTHEYNEED(1)))
		ALLOCATE(IEXCHANGES(KK)%LOCALREF(IEXCHANGES(KK)%MUCHTHEYNEED(1)))
		ALLOCATE(IEXCHANGES(KK)%SIDETHEYNEED(IEXCHANGES(KK)%MUCHTHEYNEED(1)))

		
		ALLOCATE(IEXCHANGES1(KK)%SIDETHEYNEEDN(IEXCHANGES(KK)%MUCHTHEYNEED(1)))
		ALLOCATE(IEXCHANGES1(KK)%nodex(IEXCHANGES(KK)%MUCHTHEYNEED(1),ifdn))
		ALLOCATE(IEXCHANGES1(KK)%qtheyneed(IEXCHANGES(KK)%MUCHTHEYNEED(1)))
		ALLOCATE(IEXCHANGES(KK)%qtheyneed(IEXCHANGES(KK)%MUCHTHEYNEED(1)))
		IEXCHANGES1(KK)%WHATTHEYNEED(:)=0
		IEXCHANGES(KK)%LOCALREF(:)=0
		IEXCHANGES(KK)%SIDETHEYNEED(:)=0
		IEXCHANGES1(KK)%SIDETHEYNEEDN(:)=0;IEXCHANGES1(KK)%nodex(:,:)=0
		IEXCHANGES1(KK)%qtheyneed(:)=0
		IEXCHANGES(KK)%qtheyneed(:)=0
		END IF
	END DO
!
	DO I=1,HOWMANY
		DO K=1,TEMP2
		IF (IEXCHANGES(K)%PROCID.EQ.ILISTSIDE(I)%PROCID)THEN
		IEXCHANGES(K)%SIDETHEYNEED(:)=ILISTSIDE(I)%GLOBARRAY(:)
!  		IEXCHANGES(K)%QTHEYNEED(:)=ILISTQ(I)%GLOBARRAY(:)
		END IF
		END DO
	END DO
 	CALL MPI_BARRIER(MPI_COMM_WORLD,IERROR)

	DO I=1,HOWMANY
		DO K=1,TEMP2
		IF (IEXCHANGER(I)%PROCID.EQ.IEXCHANGES(K)%PROCID)THEN
		CALL MPI_SENDRECV(IEXCHANGER1(I)%WHATINEED(1:IEXCHANGER(I)%MUCHINEED(1)),&
IEXCHANGER(I)%MUCHINEED(1),MPI_INTEGER,IEXCHANGER(I)%PROCID,&
		IEXCHANGER(I)%PROCID,IEXCHANGES1(K)%WHATTHEYNEED(1:IEXCHANGES(K)%MUCHTHEYNEED(1)),&
IEXCHANGES(K)%MUCHTHEYNEED(1),MPI_INTEGER,IEXCHANGER(I)%PROCID,&
		ICPUID,MPI_COMM_WORLD,STATUS,IERROR)
		END IF
		END DO
	END DO
	DO I=1,HOWMANY
		DO K=1,TEMP2
		IF (IEXCHANGER(I)%PROCID.EQ.IEXCHANGES(K)%PROCID)THEN
		CALL MPI_SENDRECV(IEXCHANGER1(I)%nodex(1:IEXCHANGER(I)%MUCHINEED(1),1:ifdn),&
IEXCHANGER(I)%MUCHINEED(1)*ifdn,MPI_INTEGER,IEXCHANGER(I)%PROCID,&
		IEXCHANGER(I)%PROCID,IEXCHANGES1(K)%nodex(1:IEXCHANGES(K)%MUCHTHEYNEED(1),1:ifdn),&
IEXCHANGES(K)%MUCHTHEYNEED(1)*ifdn,MPI_INTEGER,IEXCHANGER(I)%PROCID,&
		ICPUID,MPI_COMM_WORLD,STATUS,IERROR)
		END IF
		END DO
	END DO
	DO I=1,HOWMANY
		DO K=1,TEMP2
		IF (IEXCHANGER(I)%PROCID.EQ.IEXCHANGES(K)%PROCID)THEN
		CALL MPI_SENDRECV(IEXCHANGER1(I)%qineed(1:IEXCHANGER(I)%MUCHINEED(1)),&
IEXCHANGER(I)%MUCHINEED(1),MPI_INTEGER,IEXCHANGER(I)%PROCID,&
		IEXCHANGER(I)%PROCID,IEXCHANGES1(K)%qtheyneed(1:IEXCHANGES(K)%MUCHTHEYNEED(1)),&
IEXCHANGES(K)%MUCHTHEYNEED(1),MPI_INTEGER,IEXCHANGER(I)%PROCID,&
		ICPUID,MPI_COMM_WORLD,STATUS,IERROR)
		IEXCHANGES(K)%qtheyneed(1:IEXCHANGES(K)%MUCHTHEYNEED(1))=IEXCHANGES1(K)%qtheyneed(1:IEXCHANGES(K)%MUCHTHEYNEED(1))
		
		
		END IF
		END DO
	END DO

	CALL MPI_BARRIER(MPI_COMM_WORLD,IERROR)
	DO I=1,HOWMANY
		DO K=1,TEMP2
		IF (IEXCHANGER(I)%PROCID.EQ.IEXCHANGES(K)%PROCID)THEN
		CALL MPI_SENDRECV(IEXCHANGER1(I)%SIDEINEEDN(1:IEXCHANGER(I)%MUCHINEED(1)),&
IEXCHANGER(I)%MUCHINEED(1),MPI_INTEGER,IEXCHANGER(I)%PROCID,&
		IEXCHANGER(I)%PROCID,IEXCHANGES1(K)%SIDETHEYNEEDN(1:IEXCHANGES(K)%MUCHTHEYNEED(1)),&
IEXCHANGES(K)%MUCHTHEYNEED(1),MPI_INTEGER,IEXCHANGER(I)%PROCID,&
		ICPUID,MPI_COMM_WORLD,STATUS,IERROR)
		END IF
		END DO
	END DO
!make the ones below q_points!
 	CALL MPI_BARRIER(MPI_COMM_WORLD,IERROR)
	DO I=1,HOWMANY
		DO K=1,TEMP2
		IF (IEXCHANGER(I)%PROCID.EQ.IEXCHANGES(K)%PROCID)THEN
		CALL MPI_SENDRECV(IEXCHANGES(K)%SIDETHEYNEED(1:IEXCHANGES(K)%MUCHTHEYNEED(1)),&
IEXCHANGES(K)%MUCHTHEYNEED(1),MPI_INTEGER,IEXCHANGES(K)%PROCID,&
		IEXCHANGES(K)%PROCID,IEXCHANGER1(I)%SIDEINEED(1:IEXCHANGER(I)%MUCHINEED(1)),&
IEXCHANGER(I)%MUCHINEED(1),MPI_INTEGER,IEXCHANGES(K)%PROCID,&
		ICPUID,MPI_COMM_WORLD,STATUS,IERROR)

		
		END IF
		END DO
	END DO
      
	CALL MPI_BARRIER(MPI_COMM_WORLD,IERROR)
	
	
      
	

	DEALLOCATE(ILISTSIDE,ILISTQ)
	DO I=1,TEMP2
		DO K=1,IEXCHANGES(I)%MUCHTHEYNEED(1) 			

 			IF (XMPIE(IEXCHANGES1(I)%WHATTHEYNEED(K)).EQ.N)THEN

 			IEXCHANGES(I)%LOCALREF(K)=xmpil(IEXCHANGES1(I)%WHATTHEYNEED(K))
   			end if

			
		END DO
	END DO
	DO I=1,HOWMANY
		DO K=1,TEMP2
		IF (IEXCHANGER(I)%PROCID.EQ.IEXCHANGES(K)%PROCID)THEN
		CALL MPI_SENDRECV(IEXCHANGES(K)%LOCALREF(1:IEXCHANGES(K)%MUCHTHEYNEED(1)),&
IEXCHANGES(K)%MUCHTHEYNEED(1),MPI_INTEGER,IEXCHANGES(K)%PROCID,&
		IEXCHANGES(K)%PROCID,IEXCHANGER1(I)%LOCALREF(1:IEXCHANGER(I)%MUCHINEED(1)),&
IEXCHANGER(I)%MUCHINEED(1),MPI_INTEGER,IEXCHANGER(I)%PROCID,&
		ICPUID,MPI_COMM_WORLD,STATUS,IERROR)
		END IF
		END DO
	END DO
	CALL MPI_BARRIER(MPI_COMM_WORLD,IERROR)

	
	IF (ISCHEME.GT.1)THEN
	STENCOUNTER=0
!
  	
	ALLOCATE(TOTSTENC2(imaxe))
	totstenc2=0
	

	DO I=1,KMAXE
		DO K=1,TYPESTEN
			ISTY5=0
			IF ((K.EQ.1).OR.(EES.NE.5))THEN
			ITARGET=ielem(n,i)%iNUMNEIGHBOURS
			ELSE
			ITARGET=NUMNEIGHBOURS2
			END IF
			
			
			DO KK=1,ITARGET
				IF(ILOCALSTENCIL(N,I,K,KK).GT.0)THEN
				ISTY5=ISTY5+1
				END IF
			END DO
			IF (ISTY5.EQ.ITARGET)THEN
			DO KK=1,ITARGET
					
				IIFLAG=0

					IF (XMPIE(ILOCALSTENCIL(N,I,K,KK)).EQ.N) THEN

						IIFLAG=1
					END IF

					
					IF (IIFLAG.EQ.0)THEN
					totstenc2((ILOCALSTENCIL(N,I,K,KK)))=ILOCALSTENCIL(N,I,K,KK)
					END IF
			END DO
			END IF
		END DO
	END DO

	
	
	
	KXK=0
	DO I=1,imaxe
		IF (TOTSTENC2(I).GT.0)THEN
		KXK=KXK+1
		END IF
	END DO

	ALLOCATE (STENRED(KXK))
	ALLOCATE (STENREDPROC(KXK))

	stencounter=kxk

	allocate(totstenc(stencounter))
	totstenc=0
	KXK=0
	DO I=1,imaxe
		IF (TOTSTENC2(I).GT.0)THEN
		KXK=KXK+1
		totstenc(kxk)=TOTSTENC2(I)
		END IF
	END DO



	deallocate(totstenc2)




	STENRED=0
	STENREDPROC=0
	IHMSTE=0
	KXK=0
	DO I=1,STENCOUNTER
		IF (TOTSTENC(I).GT.0)THEN
		KXK=KXK+1
		STENRED(KXK)=TOTSTENC(I)
		END IF
	END DO
	DEALLOCATE (TOTSTENC)




	DO I=1,KXK
		STENREDPROC(I)=XMPIE(STENRED(I))
	END DO
	DO I=0,ISIZE-1
		IHMSTE(I)=0
		IF (I.NE.N)THEN
		DO IX=1,KXK
		IF(STENREDPROC(IX).EQ.I)THEN
		IHMSTE(I)=IHMSTE(I)+1
		END IF
		END DO
		END IF
! 		
	END DO
	IX=0
	DO I=0,ISIZE-1
		IF (I.NE.N)THEN
		IF (IHMSTE(I).GT.0)THEN
		IX=IX+1
		END IF
		END IF
	END DO
	CALL MPI_BARRIER(MPI_COMM_WORLD,IERROR)
	ALLOCATE (ILISTSTEN(IX))
! 	ILISTSTEN(:)=0
	IX=0
	DO I=0,ISIZE-1
		IF (I.NE.N)THEN
		IF (IHMSTE(I).GT.0)THEN
		IX=IX+1
		ILISTSTEN(IX)%PROCID=I
		ALLOCATE (ILISTSTEN(IX)%LISTSARRAY(IHMSTE(I)))
		ILISTSTEN(IX)%LISTSARRAY(:)=0
		ICF=0
		DO ICX=1,kxk
		IF (STENREDPROC(ICX).EQ.I)THEN
		ICF=ICF+1
		ILISTSTEN(IX)%LISTSARRAY(ICF)=STENRED(ICX)
		END IF
		END DO

		END IF
		END IF
	END DO
	ALLOCATE (IRECEXR(IX))
	ALLOCATE (IRECEXR1(IX))
! 	IRECEXR(:)=0
	IRECEXR(:)%TOT=0
	IRECEXR(:)%TOT=IX
	ICX=0
	DO I=0,ISIZE-1
		IF (IHMSTE(I).GT.0)THEN
		ICX=ICX+1
		IRECEXR(ICX)%PROCID=I
		ALLOCATE(IRECEXR(ICX)%MUCHINEED(1))
		IRECEXR(ICX)%MUCHINEED(:)=0
		IRECEXR(ICX)%MUCHINEED(1)=IHMSTE(I)
		ALLOCATE(IRECEXR1(ICX)%WHATINEED(IRECEXR(ICX)%MUCHINEED(1)))
		ALLOCATE(IRECEXR1(ICX)%LOCALREF(IRECEXR(ICX)%MUCHINEED(1)))
		ALLOCATE(IRECEXR1(ICX)%ISHAPE(IRECEXR(ICX)%MUCHINEED(1)))
		IRECEXR1(ICX)%WHATINEED(:)=0
		IRECEXR1(ICX)%LOCALREF(:)=0
		IRECEXR1(ICX)%ISHAPE(:)=0
! 		
		DO ICF=1,IX
		IF (ILISTSTEN(ICF)%PROCID.EQ.IRECEXR(ICX)%PROCID)THEN
		IRECEXR1(ICX)%WHATINEED(:)=ILISTSTEN(ICF)%LISTSARRAY(:)
! 		
		END IF
		END DO
		END IF
	END DO
	

	
	SENDSTWH(:)=0
	ICPUID=N
	DO K=0,ISIZE-1
		IXFLAG=0
		ITEEDUM=0
		ITEE=0
		IF (K.NE.N)THEN
		DO I=1,ICX
			IF (IRECEXR(I)%PROCID.EQ.K)THEN
			CALL MPI_SENDRECV(IRECEXR(I)%MUCHINEED(1),1,MPI_INTEGER,IRECEXR(I)%PROCID,ICPUID,&
			ITEE,1,MPI_INTEGER,IRECEXR(I)%PROCID,IRECEXR(I)%PROCID,MPI_COMM_WORLD,STATUS,IERROR)
			SENDSTWH(IRECEXR(I)%PROCID)=ITEE
			IXFLAG=1
			END IF
		END DO
		IF (IXFLAG.EQ.0)THEN
			CALL MPI_SENDRECV(ITEEDUM,1,MPI_INTEGER,K,ICPUID,&
			ITEE,1,MPI_INTEGER,K,K,MPI_COMM_WORLD,STATUS,IERROR)
			SENDSTWH(K)=ITEE
		END IF
		END IF
	END DO	
	CALL MPI_BARRIER(MPI_COMM_WORLD,IERROR)
	TEMP2=0
	DO I=0,ISIZE-1
		IF (SENDSTWH(I).GT.0)THEN
		TEMP2=TEMP2+1
		END IF
	END DO

	CALL MPI_BARRIER(MPI_COMM_WORLD,IERROR)
	ALLOCATE (IRECEXS(TEMP2))
	ALLOCATE (IRECEXS1(TEMP2))
! 	IRECEXS(:)=0
	IRECEXS(:)%TOT=TEMP2
	KK=0
	

	
	DO I=0,ISIZE-1
		IF (SENDSTWH(I).GT.0)THEN
		KK=KK+1
		IRECEXS(KK)%PROCID=I
		ALLOCATE(IRECEXS(KK)%MUCHTHEYNEED(1))
		IRECEXS(KK)%MUCHTHEYNEED(:)=0
		IRECEXS(KK)%MUCHTHEYNEED(1)=SENDSTWH(I)
		ALLOCATE(IRECEXS1(KK)%WHATTHEYNEED(IRECEXS(KK)%MUCHTHEYNEED(1)))
		ALLOCATE(IRECEXS(KK)%LOCALREF(IRECEXS(KK)%MUCHTHEYNEED(1)))
		ALLOCATE(IRECEXS1(KK)%ISHAPE(IRECEXS(KK)%MUCHTHEYNEED(1)))
		IRECEXS1(KK)%WHATTHEYNEED(:)=0
		IRECEXS(KK)%LOCALREF(:)=0
		IRECEXS1(KK)%ISHAPE(:)=0
		END IF
	END DO
	
			RUMTS(1:1)=0
	
	CALL MPI_BARRIER(MPI_COMM_WORLD,IERROR)
	
	

	
	DO I=0,ISIZE-1
			IF (I.NE.N) THEN
				DO J=1,TEMP2
					IAVT=10000
					IF (IRECEXS(J)%PROCID.EQ.I)THEN
					IAVT=J 
					GO TO 7001
					END IF
				END DO
				7001 CONTINUE
				DO K=1,ICX
					IAVC=10000
					IF (IRECEXR(K)%PROCID.EQ.I) THEN
					IAVC=K
					GO TO 8001
					END IF
				END DO
				8001 CONTINUE
IF ((IAVC.EQ.10000).AND.(IAVT.NE.10000)) THEN
CALL MPI_SENDRECV(SUMTS(1:1),1,MPI_INTEGER,I,ICPUID,&
IRECEXS1(IAVT)%WHATTHEYNEED(1:IRECEXS(IAVT)%MUCHTHEYNEED(1)),IRECEXS(IAVT)%MUCHTHEYNEED(1),&
MPI_INTEGER,IRECEXS(IAVT)%PROCID,IRECEXS(IAVT)%PROCID,MPI_COMM_WORLD,STATUS,IERROR)
END IF
IF ((IAVC.EQ.10000).AND.(IAVT.EQ.10000)) THEN
CALL MPI_SENDRECV(SUMTS(1:1),1,MPI_INTEGER,I,ICPUID,&
RUMTS(1:1),1,MPI_INTEGER,I,I,MPI_COMM_WORLD,STATUS,IERROR)
END IF
 IF ((IAVC.NE.10000).AND.(IAVT.EQ.10000)) THEN
 CALL MPI_SENDRECV(IRECEXR1(IAVC)%WHATINEED(1:IRECEXR(IAVC)%MUCHINEED(1)),IRECEXR(IAVC)%MUCHINEED(1),&
 MPI_INTEGER,IRECEXR(IAVC)%PROCID,ICPUID,RUMTS(1:1),1,MPI_INTEGER,I,I,MPI_COMM_WORLD,STATUS,IERROR)
 END IF
IF ((IAVC.NE.10000).AND.(IAVT.NE.10000)) THEN
CALL MPI_SENDRECV(IRECEXR1(IAVC)%WHATINEED(1:IRECEXR(IAVC)%MUCHINEED(1)),IRECEXR(IAVC)%MUCHINEED(1),&
MPI_INTEGER,IRECEXR(IAVC)%PROCID,ICPUID,&
IRECEXS1(IAVT)%WHATTHEYNEED(1:IRECEXS(IAVT)%MUCHTHEYNEED(1)),IRECEXS(IAVT)%MUCHTHEYNEED(1),MPI_INTEGER,&
IRECEXS(IAVT)%PROCID,IRECEXS(IAVT)%PROCID,MPI_COMM_WORLD,STATUS,IERROR)
END IF
			!	END DO !K
			!END DO! J
			END IF	! I.NE.N
	END DO
	CALL MPI_BARRIER(MPI_COMM_WORLD,IERROR)
! 	
	   	
	DO I=1,TEMP2
		DO K=1,IRECEXS(I)%MUCHTHEYNEED(1)
			!DO J=1,KMAXE
			IF (XMPIE(IRECEXS1(I)%WHATTHEYNEED(K)).EQ.N) THEN
			J=XMPIL(IRECEXS1(I)%WHATTHEYNEED(K))
			!IF (IRECEXS(I)%WHATTHEYNEED(K).EQ.IELEM(N,J)%IHEXGL)THEN
			IRECEXS(I)%LOCALREF(K)=j
			IRECEXS1(I)%ISHAPE(K)=IELEM(N,J)%ISHAPE
			
			END IF
			!END DO
		END DO
	END DO
	CALL MPI_BARRIER(MPI_COMM_WORLD,IERROR)
		DO I=0,ISIZE-1
			RUMTS=0
			SUMTS=0
			IF (I.NE.N) THEN
				DO J=1,TEMP2
					IAVT=10000
					IF (IRECEXS(J)%PROCID.EQ.I)THEN
					IAVT=J 
					GO TO 9001
					END IF
				END DO
				9001 CONTINUE
				DO K=1,ICX
					IAVC=10000
					IF (IRECEXR(K)%PROCID.EQ.I) THEN
					IAVC=K
					GO TO 10001
					END IF
				END DO
				10001 CONTINUE
			
  IF ((IAVT.EQ.10000).AND.(IAVC.NE.10000)) THEN
  CALL MPI_SENDRECV(SUMTS(1:1),1,MPI_INTEGER,I,ICPUID,&
  IRECEXR1(IAVC)%LOCALREF(1:IRECEXR(IAVC)%MUCHINEED(1)),IRECEXR(IAVC)%MUCHINEED(1),&
MPI_INTEGER,IRECEXR(IAVC)%PROCID,IRECEXR(IAVC)%PROCID,MPI_COMM_WORLD,STATUS,IERROR)
  CALL MPI_SENDRECV(SUMTS(1:1),1,MPI_INTEGER,I,ICPUID,&
  IRECEXR1(IAVC)%ISHAPE(1:IRECEXR(IAVC)%MUCHINEED(1)),IRECEXR(IAVC)%MUCHINEED(1),&
MPI_INTEGER,IRECEXR(IAVC)%PROCID,IRECEXR(IAVC)%PROCID,MPI_COMM_WORLD,STATUS,IERROR)
  END IF
   IF ((IAVT.EQ.10000).AND.(IAVC.EQ.10000)) THEN
   CALL MPI_SENDRECV(SUMTS(1:1),1,MPI_INTEGER,I,ICPUID,&
   RUMTS(1:1),1,MPI_INTEGER,I,I,MPI_COMM_WORLD,STATUS,IERROR)
   CALL MPI_SENDRECV(SUMTS(1:1),1,MPI_INTEGER,I,ICPUID,&
   RUMTS(1:1),1,MPI_INTEGER,I,I,MPI_COMM_WORLD,STATUS,IERROR)
   END IF
  IF ((IAVT.NE.10000).AND.(IAVC.EQ.10000)) THEN
  CALL MPI_SENDRECV(IRECEXS(IAVT)%LOCALREF(1:IRECEXS(IAVT)%MUCHTHEYNEED(1)),&
IRECEXS(IAVT)%MUCHTHEYNEED(1),MPI_INTEGER,IRECEXS(IAVT)%PROCID,ICPUID,&
  RUMTS(1:1),1,MPI_INTEGER,I,I,MPI_COMM_WORLD,STATUS,IERROR)
  CALL MPI_SENDRECV(IRECEXS1(IAVT)%ISHAPE(1:IRECEXS(IAVT)%MUCHTHEYNEED(1)),&
  IRECEXS(IAVT)%MUCHTHEYNEED(1),MPI_INTEGER,IRECEXS(IAVT)%PROCID,ICPUID,&
  RUMTS(1:1),1,MPI_INTEGER,I,I,MPI_COMM_WORLD,STATUS,IERROR)
  END IF
  IF ((IAVT.NE.10000).AND.(IAVC.NE.10000)) THEN
  CALL MPI_SENDRECV(IRECEXS(IAVT)%LOCALREF(1:IRECEXS(IAVT)%MUCHTHEYNEED(1)),&
IRECEXS(IAVT)%MUCHTHEYNEED(1),MPI_INTEGER,IRECEXS(IAVT)%PROCID,ICPUID,IRECEXR1(IAVC)%LOCALREF(1:IRECEXR(IAVC)%MUCHINEED(1)),&
IRECEXR(IAVC)%MUCHINEED(1),MPI_INTEGER,IRECEXR(IAVC)%PROCID,IRECEXR(IAVC)%PROCID,MPI_COMM_WORLD,STATUS,IERROR)
  CALL MPI_SENDRECV(IRECEXS1(IAVT)%ISHAPE(1:IRECEXS(IAVT)%MUCHTHEYNEED(1)),IRECEXS(IAVT)%MUCHTHEYNEED(1),&
  MPI_INTEGER,IRECEXS(IAVT)%PROCID,ICPUID,IRECEXR1(IAVC)%ISHAPE(1:IRECEXR(IAVC)%MUCHINEED(1)),IRECEXR(IAVC)%MUCHINEED(1)&
  ,MPI_INTEGER,IRECEXR(IAVC)%PROCID,IRECEXR(IAVC)%PROCID,MPI_COMM_WORLD,STATUS,IERROR)
  END IF
			
			END IF	! I.NE.N
		END DO
	CALL MPI_BARRIER(MPI_COMM_WORLD,IERROR)
	deALLOCATE (STENRED)
	deALLOCATE (STENREDPROC)
	DEALLOCATE (ILISTSTEN)
	END IF	
      
	
	deALLOCATE (ILISTGLO)
	




	!TEMPORARY ALLOCATE

	
END SUBROUTINE ESTABEXHANGE

SUBROUTINE EXCHANGE_LOWER(N)
!> @brief
!> This subroutine is exchanging the variables of all the halo cells for direct side neighbours only
!> and is primarily used by lower order schemes

IMPLICIT NONE
INTEGER,INTENT(IN)::N
INTEGER::I,K,INEEDT,TNEEDT,ICPUID,ITEST
INEEDT=IEXCHANGER(1)%TOT
TNEEDT=IEXCHANGES(1)%TOT

  ITEST=NOF_VARIABLES+TURBULENCEEQUATIONS+PASSIVESCALAR

  
If (( turbulence .GT. 0 ).or.(passivescalar.GT.0)) then
!$OMP DO SCHEDULE (STATIC)
DO I=1,TNEEDT
	DO K=1,IEXCHANGES(I)%MUCHTHEYNEED(1)
	      SOLCHANGES(I)%SOL(K,1:NOF_VARIABLES)=U_C(IEXCHANGES(I)%LOCALREF(K))%VAL(1,1:NOF_VARIABLES)
	      SOLCHANGES(I)%SOL(K,NOF_VARIABLES+1:NOF_VARIABLES+TURBULENCEEQUATIONS+PASSIVESCALAR)=U_CT(IEXCHANGES(I)%LOCALREF(K))%VAL(1,1:TURBULENCEEQUATIONS+PASSIVESCALAR)
	END DO
END DO
!$OMP END DO

ELSE
!$OMP DO SCHEDULE (STATIC)
DO I=1,TNEEDT
	DO K=1,IEXCHANGES(I)%MUCHTHEYNEED(1)
	      SOLCHANGES(I)%SOL(K,1:NOF_VARIABLES)=U_C(IEXCHANGES(I)%LOCALREF(K))%VAL(1,1:NOF_VARIABLES)
	END DO
END DO
!$OMP END DO
END IF




 
!$OMP BARRIER
!$OMP MASTER
ICPUID=N
DO I=1,INEEDT
		DO K=1,TNEEDT
		IF (SOLCHANGER(I)%PROCID.EQ.SOLCHANGES(K)%PROCID)THEN
		CALL MPI_SENDRECV(SOLCHANGES(K)%SOL(1:IEXCHANGES(K)%MUCHTHEYNEED(1),1:ITEST),&
IEXCHANGES(K)%MUCHTHEYNEED(1)*ITEST,MPI_DOUBLE_PRECISION,SOLCHANGER(I)%PROCID,&
		SOLCHANGES(K)%PROCID,SOLCHANGER(I)%SOL(1:IEXCHANGER(I)%MUCHINEED(1),1:ITEST),&
IEXCHANGER(I)%MUCHINEED(1)*ITEST,MPI_DOUBLE_PRECISION,&
		SOLCHANGER(I)%PROCID,ICPUID,MPI_COMM_WORLD,STATUS,IERROR)
		END IF
		END DO
END DO
!$OMP END MASTER 
!$OMP BARRIER

END SUBROUTINE EXCHANGE_LOWER
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
SUBROUTINE EXCHANGE_HIGHER(N)
!> @brief
!> This subroutine is exchanging the variables of all the halo cells for all the reconstruction stencils
IMPLICIT NONE
INTEGER,INTENT(IN)::N
INTEGER::I,J,K,L,M,O,P,Q,INEEDT,TNEEDT,INDL,TNDL,ICPUID,ITEST,ITEE,ITEEDUM,ITEMP1,ITEMP2,IAVC,IAVT
REAL,DIMENSION(1:1)::DUMTS,RUMTS
integer:: n_requests
integer, dimension(:), allocatable:: requests
	
ITEST=nof_Variables+TURBULENCEEQUATIONS+PASSIVESCALAR

INEEDT=IRECEXR(1)%TOT
TNEEDT=IRECEXS(1)%TOT

If (( turbulence .GT. 0).or.(passivescalar.GT.0)) then
!$OMP DO SCHEDULE (STATIC)
DO I=1,TNEEDT
	DO K=1,IRECEXS(I)%MUCHTHEYNEED(1)
		  IEXSOLHIS(I)%SOL(K,1:nof_Variables)=U_C(IRECEXS(I)%LOCALREF(K))%VAL(1,1:nof_Variables)
		  IEXSOLHIS(I)%SOL(K,NOF_VARIABLES+1:NOF_VARIABLES+TURBULENCEEQUATIONS+PASSIVESCALAR)=U_CT(IRECEXS(I)%LOCALREF(K))%VAL(1,1:TURBULENCEEQUATIONS+PASSIVESCALAR)
		  
	END DO
END DO
!$OMP END DO

else
!$OMP DO SCHEDULE (STATIC)
DO I=1,TNEEDT
	DO K=1,IRECEXS(I)%MUCHTHEYNEED(1)
		  IEXSOLHIS(I)%SOL(K,1:nof_Variables+TURBULENCEEQUATIONS+PASSIVESCALAR)=U_C(IRECEXS(I)%LOCALREF(K))%VAL(1,1:nof_Variables+TURBULENCEEQUATIONS+PASSIVESCALAR)
	END DO
END DO
!$OMP END DO
end if



!$OMP BARRIER
!$OMP MASTER
n_requests = 0

allocate(requests(jtotal*2))
requests(:)=0
ICPUID=N

do k=1,jtotal
        

        if ((jtot(k,1).eq.-1).AND.(jtot(k,2).NE.-1))then
        
        
        
          n_requests = n_requests + 1
        iavC=jtot(k,2)
!        
        CALL MPI_ISEND(                                                     &
      DUMTS(1:1), & !sendbuf
      1, MPI_DOUBLE_PRECISION,       & !sendcount, sendtype
      JTOT(K,3), 0,                                        & !destination, tag
      MPI_COMM_WORLD, requests(n_requests), ierror                     & !communicator, request handle, error
   )


         n_requests = n_requests + 1
         iavC=jtot(k,2)
         
   CALL MPI_IRECV(                                                     &
      IEXSOLHIR(IAVC)%SOL(1:IRECEXR(IAVC)%MUCHINEED(1),1:ITEST),    & !recvbuf
      IRECEXR(iavc)%MUCHINEED(1)*ITEST, MPI_DOUBLE_PRECISION,          & !recvcount, recvtype
     IEXSOLHIR(IAVC)%PROCID, 0,                                        & !source, tag
      MPI_COMM_WORLD, requests(n_requests), ierror                     & !communicator, request handle, error
   )
        END IF
        
       if ((jtot(k,1).NE.-1).AND.(jtot(k,2).EQ.-1))then
        
        n_requests = n_requests + 1
        iavT=jtot(k,1)
!         
        CALL MPI_ISEND(                                                     &
      IEXSOLHIS(IAVT)%SOL(1:IRECEXS(IAVT)%MUCHTHEYNEED(1),1:ITEST), & !sendbuf
      IRECEXS(IAVT)%MUCHTHEYNEED(1)*ITEST, MPI_DOUBLE_PRECISION,       & !sendcount, sendtype
      IEXSOLHIS(IAVT)%PROCID, 0,                                        & !destination, tag
      MPI_COMM_WORLD, requests(n_requests), ierror                     & !communicator, request handle, error
   )


         n_requests = n_requests + 1
         iavT=jtot(k,1)
   CALL MPI_IRECV(                                                     &
      DUMTS(1:1),    & !recvbuf
      1, MPI_DOUBLE_PRECISION,          & !recvcount, recvtype
     jtot(k,3), 0,                                        & !source, tag
      MPI_COMM_WORLD, requests(n_requests), ierror                     & !communicator, request handle, error
   )
        
        
        
        END IF
        
        
        
        if ((jtot(k,1).NE.-1).AND.(jtot(k,2).NE.-1))then
        
       
       
        
        
         n_requests = n_requests + 1
        iavt=jtot(k,1)
         iavC=jtot(k,2)
!          
        CALL MPI_ISEND(                                                     &
      IEXSOLHIS(IAVT)%SOL(1:IRECEXS(IAVT)%MUCHTHEYNEED(1),1:ITEST), & !sendbuf
      IRECEXS(IAVT)%MUCHTHEYNEED(1)*ITEST, MPI_DOUBLE_PRECISION,       & !sendcount, sendtype
      IEXSOLHIS(IAVT)%PROCID, 0,                                        & !destination, tag
      MPI_COMM_WORLD, requests(n_requests), ierror                     & !communicator, request handle, error
   )


         n_requests = n_requests + 1
         iavC=jtot(k,2)
   CALL MPI_IRECV(                                                     &
      IEXSOLHIR(IAVC)%SOL(1:IRECEXR(IAVC)%MUCHINEED(1),1:ITEST),    & !recvbuf
      IRECEXR(iavc)%MUCHINEED(1)*ITEST, MPI_DOUBLE_PRECISION,          & !recvcount, recvtype
     IEXSOLHIR(IAVC)%PROCID, 0,                                        & !source, tag
      MPI_COMM_WORLD, requests(n_requests), ierror                     & !communicator, request handle, error
   )
        
        
        
        
       end if
       
end do

       

CALL MPI_WAITALL(n_requests, requests, MPI_STATUSES_IGNORE, ierror)

deallocate(requests)

!$OMP END MASTER 
!$OMP BARRIER
	


END SUBROUTINE EXCHANGE_HIGHER


SUBROUTINE EXCHANGE_HIGHER_av(N)
!> @brief
!> This subroutine is exchanging the averaged variables of all the halo cells for all the reconstruction stencils
IMPLICIT NONE
INTEGER,INTENT(IN)::N
INTEGER::I,J,K,L,M,O,P,Q,INEEDT,TNEEDT,INDL,TNDL,ICPUID,ITEST,ITEE,ITEEDUM,ITEMP1,ITEMP2,IAVC,IAVT
REAL,DIMENSION(1:1)::DUMTS,RUMTS
integer:: n_requests,ind1
integer, dimension(:), allocatable:: requests
if (rungekutta.eq.4)then
ind1=7
else
ind1=5
end if


ITEST=nof_Variables+TURBULENCEEQUATIONS+PASSIVESCALAR

INEEDT=IRECEXR(1)%TOT
TNEEDT=IRECEXS(1)%TOT

If (( turbulence .GT. 0).or.(passivescalar.GT.0)) then
!$OMP DO SCHEDULE (STATIC)
DO I=1,TNEEDT
	DO K=1,IRECEXS(I)%MUCHTHEYNEED(1)
		  IEXSOLHIS(I)%SOL(K,1:nof_Variables)=U_C(IRECEXS(I)%LOCALREF(K))%VAL(ind1,1:nof_Variables)
		  IEXSOLHIS(I)%SOL(K,NOF_VARIABLES+1:NOF_VARIABLES+TURBULENCEEQUATIONS+PASSIVESCALAR)=U_CT(IRECEXS(I)%LOCALREF(K))%VAL(ind1,1:TURBULENCEEQUATIONS+PASSIVESCALAR)
		  
	END DO
END DO
!$OMP END DO

else
!  SOLCHANGES(I)%SOL(K,1:NOF_VARIABLES)=U_C(IEXCHANGES(I)%LOCALREF(K))%VAL(1,1:NOF_VARIABLES)
!$OMP DO SCHEDULE (STATIC)
DO I=1,TNEEDT
	DO K=1,IRECEXS(I)%MUCHTHEYNEED(1)
		  IEXSOLHIS(I)%SOL(K,1:nof_Variables+TURBULENCEEQUATIONS+PASSIVESCALAR)=U_C(IRECEXS(I)%LOCALREF(K))%VAL(ind1,1:nof_Variables+TURBULENCEEQUATIONS+PASSIVESCALAR)
	END DO
END DO
!$OMP END DO
end if


!$OMP BARRIER
!$OMP MASTER
n_requests = 0

allocate(requests(jtotal*2))
requests(:)=0
ICPUID=N

do k=1,jtotal
        

        if ((jtot(k,1).eq.-1).AND.(jtot(k,2).NE.-1))then
        
        
        
          n_requests = n_requests + 1
        iavC=jtot(k,2)
!        
        CALL MPI_ISEND(                                                     &
      DUMTS(1:1), & !sendbuf
      1, MPI_DOUBLE_PRECISION,       & !sendcount, sendtype
      JTOT(K,3), 0,                                        & !destination, tag
      MPI_COMM_WORLD, requests(n_requests), ierror                     & !communicator, request handle, error
   )


         n_requests = n_requests + 1
         iavC=jtot(k,2)
         
   CALL MPI_IRECV(                                                     &
      IEXSOLHIR(IAVC)%SOL(1:IRECEXR(IAVC)%MUCHINEED(1),1:ITEST),    & !recvbuf
      IRECEXR(iavc)%MUCHINEED(1)*ITEST, MPI_DOUBLE_PRECISION,          & !recvcount, recvtype
     IEXSOLHIR(IAVC)%PROCID, 0,                                        & !source, tag
      MPI_COMM_WORLD, requests(n_requests), ierror                     & !communicator, request handle, error
   )
        END IF
        
       if ((jtot(k,1).NE.-1).AND.(jtot(k,2).EQ.-1))then
        
        n_requests = n_requests + 1
        iavT=jtot(k,1)
!         
        CALL MPI_ISEND(                                                     &
      IEXSOLHIS(IAVT)%SOL(1:IRECEXS(IAVT)%MUCHTHEYNEED(1),1:ITEST), & !sendbuf
      IRECEXS(IAVT)%MUCHTHEYNEED(1)*ITEST, MPI_DOUBLE_PRECISION,       & !sendcount, sendtype
      IEXSOLHIS(IAVT)%PROCID, 0,                                        & !destination, tag
      MPI_COMM_WORLD, requests(n_requests), ierror                     & !communicator, request handle, error
   )


         n_requests = n_requests + 1
         iavT=jtot(k,1)
   CALL MPI_IRECV(                                                     &
      DUMTS(1:1),    & !recvbuf
      1, MPI_DOUBLE_PRECISION,          & !recvcount, recvtype
     jtot(k,3), 0,                                        & !source, tag
      MPI_COMM_WORLD, requests(n_requests), ierror                     & !communicator, request handle, error
   )
        
        
        
        END IF
        
        
        
        if ((jtot(k,1).NE.-1).AND.(jtot(k,2).NE.-1))then
        
       
       
        
        
         n_requests = n_requests + 1
        iavt=jtot(k,1)
         iavC=jtot(k,2)
!          
        CALL MPI_ISEND(                                                     &
      IEXSOLHIS(IAVT)%SOL(1:IRECEXS(IAVT)%MUCHTHEYNEED(1),1:ITEST), & !sendbuf
      IRECEXS(IAVT)%MUCHTHEYNEED(1)*ITEST, MPI_DOUBLE_PRECISION,       & !sendcount, sendtype
      IEXSOLHIS(IAVT)%PROCID, 0,                                        & !destination, tag
      MPI_COMM_WORLD, requests(n_requests), ierror                     & !communicator, request handle, error
   )


         n_requests = n_requests + 1
         iavC=jtot(k,2)
   CALL MPI_IRECV(                                                     &
      IEXSOLHIR(IAVC)%SOL(1:IRECEXR(IAVC)%MUCHINEED(1),1:ITEST),    & !recvbuf
      IRECEXR(iavc)%MUCHINEED(1)*ITEST, MPI_DOUBLE_PRECISION,          & !recvcount, recvtype
     IEXSOLHIR(IAVC)%PROCID, 0,                                        & !source, tag
      MPI_COMM_WORLD, requests(n_requests), ierror                     & !communicator, request handle, error
   )
        
        
        
        
       end if
       
end do

       

CALL MPI_WAITALL(n_requests, requests, MPI_STATUSES_IGNORE, ierror)

deallocate(requests)

!$OMP END MASTER 
!$OMP BARRIER
	


END SUBROUTINE EXCHANGE_HIGHER_Av



SUBROUTINE EXCHANGE_HIGHER_pre(N)
!> @brief
!> This subroutine is establishing the communication pattern and allocating the appropriate memory for 
!> exchanging the variables of all the halo cells for all the reconstruction stencils
IMPLICIT NONE
INTEGER,INTENT(IN)::N
INTEGER::I,J,K,L,M,O,P,Q,INEEDT,TNEEDT,INDL,TNDL,ICPUID,ITEST,ITEE,ITEEDUM,ITEMP1,ITEMP2,IAVC,IAVT
REAL,DIMENSION(1:1)::DUMTS,RUMTS

	
ITEST=nof_Variables+TURBULENCEEQUATIONS+PASSIVESCALAR

INEEDT=IRECEXR(1)%TOT
TNEEDT=IRECEXS(1)%TOT

If (( turbulence .GT. 0).or.(passivescalar.GT.0)) then
!$OMP DO SCHEDULE (STATIC)
DO I=1,TNEEDT
	DO K=1,IRECEXS(I)%MUCHTHEYNEED(1)
		  IEXSOLHIS(I)%SOL(K,1:nof_Variables)=U_C(IRECEXS(I)%LOCALREF(K))%VAL(1,1:nof_Variables)
		  IEXSOLHIS(I)%SOL(K,NOF_VARIABLES+1:NOF_VARIABLES+TURBULENCEEQUATIONS+PASSIVESCALAR)=U_CT(IRECEXS(I)%LOCALREF(K))%VAL(1,1:TURBULENCEEQUATIONS+PASSIVESCALAR)
		  
	END DO
END DO
!$OMP END DO

else
!  SOLCHANGES(I)%SOL(K,1:NOF_VARIABLES)=U_C(IEXCHANGES(I)%LOCALREF(K))%VAL(1,1:NOF_VARIABLES)
!$OMP DO SCHEDULE (STATIC)
DO I=1,TNEEDT
	DO K=1,IRECEXS(I)%MUCHTHEYNEED(1)
		  IEXSOLHIS(I)%SOL(K,1:nof_Variables+TURBULENCEEQUATIONS+PASSIVESCALAR)=U_C(IRECEXS(I)%LOCALREF(K))%VAL(1,1:nof_Variables+TURBULENCEEQUATIONS+PASSIVESCALAR)
	END DO
END DO
!$OMP END DO
end if

!$OMP BARRIER
!$OMP MASTER

jtotal=0;jtotal1=0;jtotal2=0;jtotal3=0
ICPUID=N
 DUMTS=ZERO
		DO I=0,ISIZE-1
			IF (I.NE.N) THEN
				DO J=1,TNEEDT
					IAVT=10000
					IF (IRECEXS(J)%PROCID.EQ.I)THEN
					ITEMP1=IRECEXS(J)%MUCHTHEYNEED(1)*ITEST
					IAVT=J 
					GO TO 7001
                                   
					END IF
				END DO
				7001 CONTINUE
				DO K=1,INEEDT
					IAVC=10000
					IF (IRECEXR(K)%PROCID.EQ.I) THEN
					IAVC=K
					ITEMP2=IRECEXR(K)%MUCHINEED(1)*ITEST
					GO TO 8001
					
					END IF
				END DO
				8001 CONTINUE
				IF ((IAVT.EQ.10000).AND.(IAVC.NE.10000)) THEN
				!MESSAGE 1
! 				
				jtotal1=jtotal1+1
				CALL MPI_SENDRECV(DUMTS(1:1),1,MPI_DOUBLE_PRECISION,I,ICPUID,&
				IEXSOLHIR(IAVC)%SOL(1:IRECEXR(IAVC)%MUCHINEED(1),1:ITEST),&
			      ITEMP2,MPI_DOUBLE_PRECISION,IEXSOLHIR(IAVC)%PROCID,IEXSOLHIR(IAVC)%PROCID,MPI_COMM_WORLD,STATUS,IERROR)			
				END IF
				IF ((IAVT.NE.10000).AND.(IAVC.EQ.10000)) THEN
				!MESSAGE 1
! 			
				jtotal2=jtotal2+1
				CALL MPI_SENDRECV(IEXSOLHIS(IAVT)%SOL(1:IRECEXS(IAVT)%MUCHTHEYNEED(1),1:ITEST),ITEMP1,&
			      MPI_DOUBLE_PRECISION,IEXSOLHIS(IAVT)%PROCID,ICPUID,&
				DUMTS(1:1),1,MPI_DOUBLE_PRECISION,I,I,MPI_COMM_WORLD,STATUS,IERROR)
				END IF
				IF ((IAVT.NE.10000).AND.(IAVC.NE.10000)) THEN
				!MESSAGE 1
				jtotal3=jtotal3+1
! 				
				
				CALL MPI_SENDRECV(IEXSOLHIS(IAVT)%SOL(1:IRECEXS(IAVT)%MUCHTHEYNEED(1),1:ITEST),ITEMP1,&
			      MPI_DOUBLE_PRECISION,IEXSOLHIS(IAVT)%PROCID,ICPUID,&
				IEXSOLHIR(IAVC)%SOL(1:IRECEXR(IAVC)%MUCHINEED(1),1:ITEST),ITEMP2,MPI_DOUBLE_PRECISION,&
			      IEXSOLHIR(IAVC)%PROCID,IEXSOLHIR(IAVC)%PROCID,MPI_COMM_WORLD,STATUS,IERROR)
				END IF		
			END IF	
		END DO
		
		
		allocate(jtot1(jtotal1,3),jtot2(jtotal2,3),jtot3(jtotal3,3),jtot(jtotal1+jtotal2+jtotal3,3))
		jtot1(:,:)=-1;jtot2(:,:)=-1;jtot3(:,:)=-1;jtot(:,:)=-1
!  		
		jtotal=0;jtotal1=0;jtotal2=0;jtotal3=0
		
ICPUID=N
 DUMTS=ZERO
		DO I=0,ISIZE-1
			IF (I.NE.N) THEN
				DO J=1,TNEEDT
					IAVT=10000
					IF (IRECEXS(J)%PROCID.EQ.I)THEN
					ITEMP1=IRECEXS(J)%MUCHTHEYNEED(1)*ITEST
					IAVT=J 
					GO TO 10001
                                   
					END IF
				END DO
				10001 CONTINUE
				DO K=1,INEEDT
					IAVC=10000
					IF (IRECEXR(K)%PROCID.EQ.I) THEN
					IAVC=K
					ITEMP2=IRECEXR(K)%MUCHINEED(1)*ITEST
					GO TO 11001
					
					END IF
				END DO
				11001 CONTINUE
				IF ((IAVT.EQ.10000).AND.(IAVC.NE.10000)) THEN
				!MESSAGE 1
! 				jtotal1=jtotal1+1
! 				jtot1(jtotal1,1)=-1
! 				jtot1(jtotal1,2)=j
				
				jtotal=jtotal+1
				jtot(jtotal,1)=-1
				jtot(jtotal,2)=k
				jtot(jtotal,3)=i
				CALL MPI_SENDRECV(DUMTS(1:1),1,MPI_DOUBLE_PRECISION,I,ICPUID,&
				IEXSOLHIR(IAVC)%SOL(1:IRECEXR(IAVC)%MUCHINEED(1),1:ITEST),&
			      ITEMP2,MPI_DOUBLE_PRECISION,IEXSOLHIR(IAVC)%PROCID,IEXSOLHIR(IAVC)%PROCID,MPI_COMM_WORLD,STATUS,IERROR)			
				END IF
				IF ((IAVT.NE.10000).AND.(IAVC.EQ.10000)) THEN
				!MESSAGE 1
! 				jtotal2=jtotal2+1
! 				jtot1(jtotal2,1)=k
! 				jtot1(jtotal2,2)=-1
				jtotal=jtotal+1
				jtot(jtotal,1)=j
				jtot(jtotal,2)=-1
				jtot(jtotal,3)=i
				CALL MPI_SENDRECV(IEXSOLHIS(IAVT)%SOL(1:IRECEXS(IAVT)%MUCHTHEYNEED(1),1:ITEST),ITEMP1,&
			      MPI_DOUBLE_PRECISION,IEXSOLHIS(IAVT)%PROCID,ICPUID,&
				DUMTS(1:1),1,MPI_DOUBLE_PRECISION,I,I,MPI_COMM_WORLD,STATUS,IERROR)
				END IF
				IF ((IAVT.NE.10000).AND.(IAVC.NE.10000)) THEN
				!MESSAGE 1
! 				jtotal3=jtotal3+1
! 				jtot3(jtotal3,1)=j
! 				jtot3(jtotal3,2)=k
				jtotal=jtotal+1
				jtot(jtotal,1)=j
				jtot(jtotal,2)=k
				CALL MPI_SENDRECV(IEXSOLHIS(IAVT)%SOL(1:IRECEXS(IAVT)%MUCHTHEYNEED(1),1:ITEST),ITEMP1,&
			      MPI_DOUBLE_PRECISION,IEXSOLHIS(IAVT)%PROCID,ICPUID,&
				IEXSOLHIR(IAVC)%SOL(1:IRECEXR(IAVC)%MUCHINEED(1),1:ITEST),ITEMP2,MPI_DOUBLE_PRECISION,&
			      IEXSOLHIR(IAVC)%PROCID,IEXSOLHIR(IAVC)%PROCID,MPI_COMM_WORLD,STATUS,IERROR)
				END IF		
			END IF	
		END DO
		
		
!$OMP END MASTER 
!$OMP BARRIER
	
!                                

END SUBROUTINE EXCHANGE_HIGHER_pre









SUBROUTINE EXHBOUNDHIGHER(N)
!> @brief
!> This subroutine is communicating the boundary extrapolated values for the variables and their gradients
!> for the Gaussian quadrature points of direct-side neighbours between MPI processes 
IMPLICIT NONE
INTEGER,INTENT(IN)::N
INTEGER::I,J,K,L,M,O,P,Q,INEEDT,TNEEDT,INDL,TNDL,ICPUID,ITTT,IEX,IMULTI,K_CNT,nvar
INTEGER::ITEE,ITEEDUM,JK,JJK,JJK4,JJK12,IMULTI2,ICPE,JMNB,J76,J78,J79,J80,IMULTI3,I_CNT,cinout2
integer:: n_requests 
integer, dimension(:), allocatable:: requests
real::pr_t31,pr_t32,pr_t33,pr_t34,pr_t35,temp_prin,temp_prout
 cinout2=0
INDL=IEXCHANGER(1)%TOT
TNDL=IEXCHANGES(1)%TOT

pr_t31=zero
pr_t32=zero
pr_t33=zero
pr_t34=zero
pr_t35=zero
temp_prin=zero
temp_prout=zero



! 
!     if (statistics.eq.1)then
!     
!     !$OMP MASTER
!     pr_t31=MPI_Wtime()
! !     prace_t1=pr_t2-pr_t1
!     !$OMP END MASTER
!      
!     end if



if(indl .ne. tndl) then
   write (*, *) "exhbounhigher: INDL and TNDL are supposed to be equal; INDL=", INDL, "TNDL=", TNDL
   call MPI_ABORT(MPI_COMM_WORLD, 1, IERROR)
end if

IF (DIMENSIONA.EQ.3)THEN


IF( ITESTCASE.EQ.4)THEN
I_CNT=(nof_variables+TURBULENCEEQUATIONS+PASSIVESCALAR)+((4+TURBULENCEEQUATIONS+PASSIVESCALAR)*3)
ELSE

I_CNT=nof_variables
END IF
ELSE
IF( ITESTCASE.EQ.4)THEN
I_CNT=(nof_variables+TURBULENCEEQUATIONS+PASSIVESCALAR)+((3+TURBULENCEEQUATIONS+PASSIVESCALAR)*2)
ELSE

I_CNT=nof_variables
END IF
END IF


IF (ITESTCASE.LE.3) THEN
!$OMP DO SCHEDULE (STATIC)
    DO I=1,TNDL
        DO K=1,IEXCHANGES(I)%MUCHTHEYNEED(1)
                IEXBOUNDHIS(I)%FACESOL(K,1:NOF_VARIABLES)=ILOCAL_RECON3(IEXCHANGES(I)%LOCALREF(K))%ULEFT(1:NOF_VARIABLES,IEXCHANGEs(I)%SIDEtheyNEED(K),IEXCHANGES(I)%QTHEYNEED(k))

        END DO
    END DO
!$OMP END DO
END  IF


IF (ITESTCASE.EQ.4) THEN

IF (TURBULENCE.NE.1)THEN
!$OMP DO SCHEDULE (STATIC)
DO I=1,TNDL
DO K=1,IEXCHANGES(I)%MUCHTHEYNEED(1)
IEXBOUNDHIS(I)%FACESOL(K,1:NOF_vARIABLES)=ILOCAL_RECON3(IEXCHANGES(I)%LOCALREF(K))%ULEFT(1:NOF_vARIABLES,IEXCHANGEs(I)%SIDEtheyNEED(K),IEXCHANGES(I)%QTHEYNEED(k))

ITTT=0
DO IEX=1,NOF_VARIABLES-1
      DO nvar=1,DIMS
      ITTT=ITTT+1
		  IEXBOUNDHIS(I)%FACESOL(K,NOF_vARIABLES+ITTT)=ILOCAL_RECON3(IEXCHANGES(I)%LOCALREF(K))%ULEFTV(NVAR,IEX,IEXCHANGEs(I)%SIDEtheyNEED(K),IEXCHANGES(I)%QTHEYNEED(k))

      END DO
END DO
END DO
END DO
!$OMP END DO

ELSE
!$OMP DO SCHEDULE (STATIC)
DO I=1,TNDL
DO K=1,IEXCHANGES(I)%MUCHTHEYNEED(1)
IEXBOUNDHIS(I)%FACESOL(K,1:NOF_vARIABLES)=ILOCAL_RECON3(IEXCHANGES(I)%LOCALREF(K))%ULEFT(1:NOF_vARIABLES,IEXCHANGEs(I)%SIDEtheyNEED(K),IEXCHANGES(I)%QTHEYNEED(k))
IEXBOUNDHIS(I)%FACESOL(K,NOF_vARIABLES+1:NOF_vARIABLES+TURBULENCEEQUATIONS+PASSIVESCALAR)=ILOCAL_RECON3(IEXCHANGES(I)%LOCALREF(K))%ULEFTTURB(1:TURBULENCEEQUATIONS+PASSIVESCALAR,IEXCHANGEs(I)%SIDEtheyNEED(K),IEXCHANGES(I)%QTHEYNEED(k))


ITTT=0
DO IEX=1,NOF_VARIABLES-1
      DO nvar=1,DIMS
      ITTT=ITTT+1
		  IEXBOUNDHIS(I)%FACESOL(K,NOF_vARIABLES+TURBULENCEEQUATIONS+PASSIVESCALAR+ITTT)=ILOCAL_RECON3(IEXCHANGES(I)%LOCALREF(K))%ULEFTV(NVAR,IEX,IEXCHANGEs(I)%SIDEtheyNEED(K),IEXCHANGES(I)%QTHEYNEED(k))
      END DO
END DO
DO IEX=1,TURBULENCEEQUATIONS+PASSIVESCALAR
      DO nvar=1,DIMS
      ITTT=ITTT+1
	IEXBOUNDHIS(I)%FACESOL(K,NOF_vARIABLES+TURBULENCEEQUATIONS+PASSIVESCALAR+ITTT)=ILOCAL_RECON3(IEXCHANGES(I)%LOCALREF(K))%ULEFTTURBV(NVAR,IEX,IEXCHANGEs(I)%SIDEtheyNEED(K),IEXCHANGES(I)%QTHEYNEED(k))
      END DO
END DO
END DO
END DO
!$OMP END DO

END IF
END  IF

!$OMP BARRIER


!-------------------FOR DEBUGGING ONLY -----------------------------------------!

!-------------------FOR DEBUGGING ONLY -----------------------------------------!

!$OMP MASTER
!CALL MPI_BARRIER(mpi_comm_world,ierror)

n_requests = 0
allocate(requests(2*indl))
requests(:)=0
ICPUID=N



!     if (statistics.eq.1)then
!     
!     !$OMP MASTER
!     pr_t32=MPI_Wtime()
! !     prace_t33=pr_t32-pr_t31
!     !$OMP END MASTER
!     
!     end if








DO K=1,INDL

   ! Search unique J such that (IEXBOUNDHIR(K)%PROCID .EQ. IEXBOUNDHIS(J)%PROCID)
   J = 1
   DO WHILE(IEXBOUNDHIR(K)%PROCID .NE. IEXBOUNDHIS(J)%PROCID)
      J = J + 1
   END DO

   ! non-blocking send
   n_requests = n_requests + 1
   CALL MPI_ISEND(                                                     &
      IEXBOUNDHIS(J)%FACESOL(1:IEXCHANGES(J)%MUCHTHEYNEED(1),1:I_CNT), & !sendbuf
      IEXCHANGES(J)%MUCHTHEYNEED(1)*I_CNT, MPI_DOUBLE_PRECISION,       & !sendcount, sendtype
      IEXBOUNDHIS(J)%PROCID, 0,                                        & !destination, tag
      MPI_COMM_WORLD, requests(n_requests), ierror                     & !communicator, request handle, error
   )

   ! non-blocking receive
   n_requests = n_requests + 1
   CALL MPI_IRECV(                                                     &
      IEXBOUNDHIR(K)%FACESOL(1:IEXCHANGER(K)%MUCHINEED(1),1:I_CNT),    & !recvbuf
      IEXCHANGER(K)%MUCHINEED(1)*I_CNT, MPI_DOUBLE_PRECISION,          & !recvcount, recvtype
      IEXBOUNDHIR(K)%PROCID, 0,                                        & !source, tag
      MPI_COMM_WORLD, requests(n_requests), ierror                     & !communicator, request handle, error
   )


END DO

CALL MPI_WAITALL(n_requests, requests, MPI_STATUSES_IGNORE, ierror)

! if (statistics.eq.1)then
!     
!    
!     pr_t33=MPI_Wtime()
! !     prace_t33=pr_t32-pr_t31
!         pr_t34=pr_t33-pr_t32
!         pr_t35=pr_t32-pr_t31
!         
! !       
! 
!     
!      
!     end if




deallocate(requests)
!$OMP END MASTER
!$OMP BARRIER

END SUBROUTINE EXHBOUNDHIGHER




SUBROUTINE EXHBOUNDHIGHER2(N)
!> @brief
!> This subroutine is communicating the boundary extrapolated values for the variables and their gradients
!> for the Gaussian quadrature points of direct-side neighbours between MPI processes for the Implicit Time stepping

IMPLICIT NONE
INTEGER,INTENT(IN)::N
INTEGER::I,J,K,L,M,O,P,Q,INEEDT,TNEEDT,INDL,TNDL,ICPUID,ITTT,IEX,IMULTI,K_CNT,nvar
INTEGER::ITEE,ITEEDUM,JK,JJK,JJK4,JJK12,IMULTI2,ICPE,JMNB,J76,J78,J79,J80,IMULTI3
INDL=IEXCHANGER(1)%TOT
TNDL=IEXCHANGES(1)%TOT

IF (ITESTCASE.LT.3)THEN
	IEX=1
      IMULTI=IEX
      IMULTI2=IEX
END IF
IF (ITESTCASE.EQ.3)THEN
	IEX=nof_variables
    IMULTI2=IEX
END IF
IF (ITESTCASE.EQ.4)THEN
    K_CNT=(nof_variables+TURBULENCEEQUATIONS+PASSIVESCALAR)
      iex = (nof_variables+TURBULENCEEQUATIONS+PASSIVESCALAR)
       IMULTI2=K_CNT
       IMULTI3=K_CNT
END IF







IMULTI=IEX


IF (ITESTCASE.LE.3) THEN
!$OMP DO SCHEDULE (STATIC)
DO I=1,TNDL
DO K=1,IEXCHANGES(I)%MUCHTHEYNEED(1)

if (relax.eq.3)then
if (iscoun.eq.1)then
IEXBOUNDHISI(I)%FACESOL(K,1:iex)=-rhs(IEXCHANGES(I)%LOCALREF(K))%val(1:iex)/IMPDIAG_MF(IEXCHANGES(I)%LOCALREF(K))	
else
IEXBOUNDHISI(I)%FACESOL(K,1:iex)=-(RHS(IEXCHANGES(I)%LOCALREF(K))%VAL(1:nof_variables)+((((1.5*U_C(IEXCHANGES(I)%LOCALREF(K))%VAL(1,1:nof_Variables))-(2.0d0*U_C(IEXCHANGES(I)%LOCALREF(K))%VAL(2,1:nof_Variables))+(0.5d0*U_C(IEXCHANGES(I)%LOCALREF(K))%VAL(3,1:nof_Variables)))/(dt))*IELEM(N,IEXCHANGES(I)%LOCALREF(K))%TOTVOLUME))/IMPDIAG_MF(IEXCHANGES(I)%LOCALREF(K))	
end if


else
IEXBOUNDHISI(I)%FACESOL(K,1:iex)=IMPDU(IEXCHANGES(I)%LOCALREF(K),1:iex)
end if



	
		
		
		

END DO
END DO
!$OMP END DO
END  IF

IF (ITESTCASE.EQ.4) THEN
!$OMP DO SCHEDULE (STATIC)
DO I=1,TNDL
  DO K=1,IEXCHANGES(I)%MUCHTHEYNEED(1)

      IF ((TURBULENCE.GT.0).or.(passivescalar.gt.0))THEN
	DO JJK=1,nof_variables
	  if (relax.eq.3)then
	  if (iscoun.eq.1)then
	IEXBOUNDHISI(I)%FACESOL(K,jjk)=-rhs(IEXCHANGES(I)%LOCALREF(K))%val(jjk)/IMPDIAG_MF(IEXCHANGES(I)%LOCALREF(K))	
      else
      IEXBOUNDHISI(I)%FACESOL(K,jjk)=-(RHS(IEXCHANGES(I)%LOCALREF(K))%VAL(jjk)+((((1.5*U_C(IEXCHANGES(I)%LOCALREF(K))%VAL(1,jjk))-(2.0d0*U_C(IEXCHANGES(I)%LOCALREF(K))%VAL(2,jjk))+(0.5d0*U_C(IEXCHANGES(I)%LOCALREF(K))%VAL(3,jjk)))/(dt))*IELEM(N,IEXCHANGES(I)%LOCALREF(K))%TOTVOLUME))/IMPDIAG_MF(IEXCHANGES(I)%LOCALREF(K))	
      end if
	
	else
	  IEXBOUNDHISI(I)%FACESOL(K,JJK)=&
	  IMPDU(IEXCHANGES(I)%LOCALREF(K),JJK)
	  end if
	END DO
	
	do nvar=1,0+turbulenceequations+passivescalar
	if (relax.eq.3)then
	if (iscoun.eq.1)then
	IEXBOUNDHISI(I)%FACESOL(K,nof_variables+nvar)=-rhst(IEXCHANGES(I)%LOCALREF(K))%val(nvar)/IMPDIAGt(IEXCHANGES(I)%LOCALREF(K),nvar)	
	else
	IEXBOUNDHISI(I)%FACESOL(K,nof_variables+nvar)=-(RHSt(IEXCHANGES(I)%LOCALREF(K))%VAL(nvar)+((((1.5*U_Ct(IEXCHANGES(I)%LOCALREF(K))%VAL(1,nvar))-(2.0d0*U_Ct(IEXCHANGES(I)%LOCALREF(K))%VAL(2,nvar))+(0.5d0*U_Ct(IEXCHANGES(I)%LOCALREF(K))%VAL(3,nvar)))/(dt))*IELEM(N,IEXCHANGES(I)%LOCALREF(K))%TOTVOLUME))/IMPDIAGt(IEXCHANGES(I)%LOCALREF(K),nvar)		
	
	end if
	else
	IEXBOUNDHISI(I)%FACESOL(K,nof_variables+nvar)=&
	IMPDU(IEXCHANGES(I)%LOCALREF(K),nof_variables+nvar)
	end if
	
	
	
	
	
	
	end do
      end if
!     
    if ((turbulence .eq. 0).and.(passivescalar.eq.0)) then

    DO JJK=1,IEX
	if (relax.eq.3)then
	if (iscoun.eq.1)then
	IEXBOUNDHISI(I)%FACESOL(K,jjk)=-rhs(IEXCHANGES(I)%LOCALREF(K))%val(jjk)/IMPDIAG_MF(IEXCHANGES(I)%LOCALREF(K))	
	else
	IEXBOUNDHISI(I)%FACESOL(K,jjk)=-(RHS(IEXCHANGES(I)%LOCALREF(K))%VAL(jjk)+((((1.5*U_C(IEXCHANGES(I)%LOCALREF(K))%VAL(1,jjk))-(2.0d0*U_C(IEXCHANGES(I)%LOCALREF(K))%VAL(2,jjk))+(0.5d0*U_C(IEXCHANGES(I)%LOCALREF(K))%VAL(3,jjk)))/(dt))*IELEM(N,IEXCHANGES(I)%LOCALREF(K))%TOTVOLUME))/IMPDIAG_mf(IEXCHANGES(I)%LOCALREF(K))	
	end if
	else
	  IEXBOUNDHISI(I)%FACESOL(K,JJK)=&
	  IMPDU(IEXCHANGES(I)%LOCALREF(K),JJK)
	  end if
    END DO
    end if ! turbulence

END DO 
END DO
!$OMP END DO
END IF

!$OMP BARRIER
!$OMP MASTER
ICPUID=N
IF (ITESTCASE.LE.3) THEN
DO K=1,INDL
DO J=1,TNDL
      IF (IEXBOUNDHIRi(K)%PROCID.EQ.IEXBOUNDHISi(J)%PROCID)THEN
      CALL MPI_SENDRECV(IEXBOUNDHISI(J)%FACESOL(1:IEXCHANGES(J)%MUCHTHEYNEED(1),1:IEX)&
,IEXCHANGES(J)%MUCHTHEYNEED(1)*IMULTI2,MPI_DOUBLE_PRECISION,IEXBOUNDHISI(J)%PROCID,&
      ICPUID,IEXBOUNDHIRI(K)%FACESOL(1:IEXCHANGER(K)%MUCHINEED(1),1:IEX),&
IEXCHANGER(K)%MUCHINEED(1)*IMULTI2,MPI_DOUBLE_PRECISION,IEXBOUNDHIRI(K)%PROCID,&
      IEXBOUNDHIRI(K)%PROCID,MPI_COMM_WORLD,STATUS,IERROR)
    
      END IF
END DO
END DO
END IF



IF (ITESTCASE.EQ.4) THEN

DO K=1,INDL
DO J=1,TNDL
      IF (IEXBOUNDHIRi(K)%PROCID.EQ.IEXBOUNDHISi(J)%PROCID)THEN
      CALL MPI_SENDRECV(IEXBOUNDHISI(J)%FACESOL(1:IEXCHANGES(J)%MUCHTHEYNEED(1),1:IMULTI3),&
IEXCHANGES(J)%MUCHTHEYNEED(1)*IMULTI2,MPI_DOUBLE_PRECISION,IEXBOUNDHISI(J)%PROCID,&
      ICPUID,IEXBOUNDHIRI(K)%FACESOL(1:IEXCHANGER(K)%MUCHINEED(1),1:IMULTI3),&
IEXCHANGER(K)%MUCHINEED(1)*IMULTI2,MPI_DOUBLE_PRECISION,IEXBOUNDHIRI(K)%PROCID,&
      IEXBOUNDHIRI(K)%PROCID,MPI_COMM_WORLD,STATUS,IERROR)

      END IF
END DO
END DO
END IF
!$OMP END MASTER 
!$OMP BARRIER







END SUBROUTINE EXHBOUNDHIGHER2



SUBROUTINE EXHBOUNDHIGHERlu(N)
!> @brief
!> This subroutine is communicating the boundary extrapolated values for the variables and their gradients
!> for the Gaussian quadrature points of direct-side neighbours between MPI processes for the Implicit Time stepping

IMPLICIT NONE
INTEGER,INTENT(IN)::N
INTEGER::I,J,K,L,M,O,P,Q,INEEDT,TNEEDT,INDL,TNDL,ICPUID,ITTT,IEX,IMULTI,K_CNT,nvar
INTEGER::ITEE,ITEEDUM,JK,JJK,JJK4,JJK12,IMULTI2,ICPE,JMNB,J76,J78,J79,J80,IMULTI3
INDL=IEXCHANGER(1)%TOT
TNDL=IEXCHANGES(1)%TOT

IF (ITESTCASE.LT.3)THEN
	IEX=1
      IMULTI=IEX
      IMULTI2=IEX
END IF
IF (ITESTCASE.EQ.3)THEN
	IEX=nof_variables
    IMULTI2=IEX
END IF
IF (ITESTCASE.EQ.4)THEN
    K_CNT=(nof_variables+TURBULENCEEQUATIONS+PASSIVESCALAR)
      iex = (nof_variables+TURBULENCEEQUATIONS+PASSIVESCALAR)
       IMULTI2=K_CNT
       IMULTI3=K_CNT
END IF







IMULTI=IEX


IF (ITESTCASE.LE.3) THEN
!$OMP DO SCHEDULE (STATIC)
DO I=1,TNDL
DO K=1,IEXCHANGES(I)%MUCHTHEYNEED(1)


IEXBOUNDHISI(I)%FACESOL(K,1:iex)=IMPDU(IEXCHANGES(I)%LOCALREF(K),1:iex)




	
		
		
		

END DO
END DO
!$OMP END DO
END  IF

IF (ITESTCASE.EQ.4) THEN
!$OMP DO SCHEDULE (STATIC)
DO I=1,TNDL
  DO K=1,IEXCHANGES(I)%MUCHTHEYNEED(1)

      IF ((TURBULENCE.GT.0).or.(passivescalar.gt.0))THEN
	DO JJK=1,nof_variables
	  
	
	
	  IEXBOUNDHISI(I)%FACESOL(K,JJK)=&
	  IMPDU(IEXCHANGES(I)%LOCALREF(K),JJK)
	 
	END DO
	
	do nvar=1,0+turbulenceequations+passivescalar
	
	
	IEXBOUNDHISI(I)%FACESOL(K,nof_variables+nvar)=&
	IMPDU(IEXCHANGES(I)%LOCALREF(K),nof_variables+nvar)
	
	
	
	
	
	
	
	end do
      end if
!     
    if ((turbulence .eq. 0).and.(passivescalar.eq.0)) then

    DO JJK=1,IEX
	
	  IEXBOUNDHISI(I)%FACESOL(K,JJK)=&
	  IMPDU(IEXCHANGES(I)%LOCALREF(K),JJK)
	  
    END DO
    end if ! turbulence

END DO 
END DO
!$OMP END DO
END IF

!$OMP BARRIER
!$OMP MASTER
ICPUID=N
IF (ITESTCASE.LE.3) THEN
DO K=1,INDL
DO J=1,TNDL
      IF (IEXBOUNDHIRi(K)%PROCID.EQ.IEXBOUNDHISi(J)%PROCID)THEN
      CALL MPI_SENDRECV(IEXBOUNDHISI(J)%FACESOL(1:IEXCHANGES(J)%MUCHTHEYNEED(1),1:IEX)&
,IEXCHANGES(J)%MUCHTHEYNEED(1)*IMULTI2,MPI_DOUBLE_PRECISION,IEXBOUNDHISI(J)%PROCID,&
      ICPUID,IEXBOUNDHIRI(K)%FACESOL(1:IEXCHANGER(K)%MUCHINEED(1),1:IEX),&
IEXCHANGER(K)%MUCHINEED(1)*IMULTI2,MPI_DOUBLE_PRECISION,IEXBOUNDHIRI(K)%PROCID,&
      IEXBOUNDHIRI(K)%PROCID,MPI_COMM_WORLD,STATUS,IERROR)
    
      END IF
END DO
END DO
END IF



IF (ITESTCASE.EQ.4) THEN

DO K=1,INDL
DO J=1,TNDL
      IF (IEXBOUNDHIRi(K)%PROCID.EQ.IEXBOUNDHISi(J)%PROCID)THEN
      CALL MPI_SENDRECV(IEXBOUNDHISI(J)%FACESOL(1:IEXCHANGES(J)%MUCHTHEYNEED(1),1:IMULTI3),&
IEXCHANGES(J)%MUCHTHEYNEED(1)*IMULTI2,MPI_DOUBLE_PRECISION,IEXBOUNDHISI(J)%PROCID,&
      ICPUID,IEXBOUNDHIRI(K)%FACESOL(1:IEXCHANGER(K)%MUCHINEED(1),1:IMULTI3),&
IEXCHANGER(K)%MUCHINEED(1)*IMULTI2,MPI_DOUBLE_PRECISION,IEXBOUNDHIRI(K)%PROCID,&
      IEXBOUNDHIRI(K)%PROCID,MPI_COMM_WORLD,STATUS,IERROR)

      END IF
END DO
END DO
END IF
!$OMP END MASTER 
!$OMP BARRIER







END SUBROUTINE EXHBOUNDHIGHERlu

SUBROUTINE EXHBOUNDHIGHER_MOOD(N)
IMPLICIT NONE
INTEGER,INTENT(IN)::N
INTEGER::I,J,K,L,M,O,P,Q,INEEDT,TNEEDT,INDL,TNDL,ICPUID,ITTT,IEX,IMULTI,K_CNT,nvar
INTEGER::ITEE,ITEEDUM,JK,JJK,JJK4,JJK12,IMULTI2,ICPE,JMNB,J76,J78,J79,J80,IMULTI3,I_CNT,cinout2
integer:: n_requests
integer, dimension(:), allocatable:: requests
real::pr_t31,pr_t32,pr_t33,pr_t34,pr_t35,temp_prin,temp_prout
 cinout2=0
INDL=IEXCHANGER(1)%TOT
TNDL=IEXCHANGES(1)%TOT

pr_t31=zero
pr_t32=zero
pr_t33=zero
pr_t34=zero
pr_t35=zero
temp_prin=zero
temp_prout=zero





if(indl .ne. tndl) then
   write (*, *) "exhbounhigher: INDL and TNDL are supposed to be equal; INDL=", INDL, "TNDL=", TNDL
   call MPI_ABORT(MPI_COMM_WORLD, 1, IERROR)
end if

IF (DIMENSIONA.EQ.3)THEN


            IF( ITESTCASE.EQ.4)THEN
            I_CNT=1
            ELSE

            I_CNT=1
            END IF
ELSE
        IF( ITESTCASE.EQ.4)THEN
        I_CNT=1
        ELSE

        I_CNT=1
        END IF
END IF


IF (ITESTCASE.LE.3) THEN
!$OMP DO SCHEDULE (STATIC)
DO I=1,TNDL
DO K=1,IEXCHANGES(I)%MUCHTHEYNEED(1)
  IEXBOUNDHIS(I)%FACESOL_m(K,1)=Ielem(n,(IEXCHANGES(I)%LOCALREF(K)))%mood

END DO
END DO
!$OMP END DO
END  IF


IF (ITESTCASE.EQ.4) THEN

IF (TURBULENCE.NE.1)THEN
!$OMP DO SCHEDULE (STATIC)
DO I=1,TNDL
DO K=1,IEXCHANGES(I)%MUCHTHEYNEED(1)
IEXBOUNDHIS(I)%FACESOL(K,1:NOF_vARIABLES)=ILOCAL_RECON3(IEXCHANGES(I)%LOCALREF(K))%ULEFT(1:NOF_vARIABLES,IEXCHANGEs(I)%SIDEtheyNEED(K),IEXCHANGES(I)%QTHEYNEED(k))

ITTT=0
DO IEX=1,NOF_VARIABLES-1
      DO nvar=1,DIMS
      ITTT=ITTT+1
		  IEXBOUNDHIS(I)%FACESOL(K,NOF_vARIABLES+ITTT)=ILOCAL_RECON3(IEXCHANGES(I)%LOCALREF(K))%ULEFTV(NVAR,IEX,IEXCHANGEs(I)%SIDEtheyNEED(K),IEXCHANGES(I)%QTHEYNEED(k))

      END DO
END DO
END DO
END DO
!$OMP END DO

ELSE
!$OMP DO SCHEDULE (STATIC)
DO I=1,TNDL
DO K=1,IEXCHANGES(I)%MUCHTHEYNEED(1)
IEXBOUNDHIS(I)%FACESOL(K,1:NOF_vARIABLES)=ILOCAL_RECON3(IEXCHANGES(I)%LOCALREF(K))%ULEFT(1:NOF_vARIABLES,IEXCHANGEs(I)%SIDEtheyNEED(K),IEXCHANGES(I)%QTHEYNEED(k))
IEXBOUNDHIS(I)%FACESOL(K,NOF_vARIABLES+1:NOF_vARIABLES+TURBULENCEEQUATIONS+PASSIVESCALAR)=ILOCAL_RECON3(IEXCHANGES(I)%LOCALREF(K))%ULEFTTURB(1:TURBULENCEEQUATIONS+PASSIVESCALAR,IEXCHANGEs(I)%SIDEtheyNEED(K),IEXCHANGES(I)%QTHEYNEED(k))


ITTT=0
DO IEX=1,NOF_VARIABLES-1
      DO nvar=1,DIMS
      ITTT=ITTT+1
		  IEXBOUNDHIS(I)%FACESOL(K,NOF_vARIABLES+TURBULENCEEQUATIONS+PASSIVESCALAR+ITTT)=ILOCAL_RECON3(IEXCHANGES(I)%LOCALREF(K))%ULEFTV(NVAR,IEX,IEXCHANGEs(I)%SIDEtheyNEED(K),IEXCHANGES(I)%QTHEYNEED(k))
      END DO
END DO
DO IEX=1,TURBULENCEEQUATIONS+PASSIVESCALAR
      DO nvar=1,DIMS
      ITTT=ITTT+1
	IEXBOUNDHIS(I)%FACESOL(K,NOF_vARIABLES+TURBULENCEEQUATIONS+PASSIVESCALAR+ITTT)=ILOCAL_RECON3(IEXCHANGES(I)%LOCALREF(K))%ULEFTTURBV(NVAR,IEX,IEXCHANGEs(I)%SIDEtheyNEED(K),IEXCHANGES(I)%QTHEYNEED(k))
      END DO
END DO
END DO
END DO
!$OMP END DO

END IF
END  IF




!$OMP BARRIER
!$OMP MASTER


n_requests = 0
allocate(requests(2*indl))

ICPUID=N










DO K=1,INDL

   ! Search unique J such that (IEXBOUNDHIR(K)%PROCID .EQ. IEXBOUNDHIS(J)%PROCID)
   J = 1
   DO WHILE(IEXBOUNDHIR(K)%PROCID .NE. IEXBOUNDHIS(J)%PROCID)
      J = J + 1
   END DO

   ! non-blocking send
   n_requests = n_requests + 1
   CALL MPI_ISEND(                                                     &
      IEXBOUNDHIS(J)%FACESOL_m(1:IEXCHANGES(J)%MUCHTHEYNEED(1),1:I_CNT), & !sendbuf
      IEXCHANGES(J)%MUCHTHEYNEED(1)*I_CNT, MPI_DOUBLE_PRECISION,       & !sendcount, sendtype
      IEXBOUNDHIS(J)%PROCID, 0,                                        & !destination, tag
      MPI_COMM_WORLD, requests(n_requests), ierror                     & !communicator, request handle, error
   )

   ! non-blocking receive
   n_requests = n_requests + 1
   CALL MPI_IRECV(                                                     &
      IEXBOUNDHIR(K)%FACESOL_m(1:IEXCHANGER(K)%MUCHINEED(1),1:I_CNT),    & !recvbuf
      IEXCHANGER(K)%MUCHINEED(1)*I_CNT, MPI_DOUBLE_PRECISION,          & !recvcount, recvtype
      IEXBOUNDHIR(K)%PROCID, 0,                                        & !source, tag
      MPI_COMM_WORLD, requests(n_requests), ierror                     & !communicator, request handle, error
   )

!   CALL MPI_SENDRECV(                                                  &
!      IEXBOUNDHIS(J)%FACESOL(1:IEXCHANGES(J)%MUCHTHEYNEED(1),1:I_CNT), & !sendbuf
!      IEXCHANGES(J)%MUCHTHEYNEED(1)*I_CNT, MPI_DOUBLE_PRECISION,       & !sendcount, sendtype
!      IEXBOUNDHIS(J)%PROCID, ICPUID,                                   & !destination, tag
!      IEXBOUNDHIR(K)%FACESOL(1:IEXCHANGER(K)%MUCHINEED(1),1:I_CNT),    & !recvbuf
!      IEXCHANGER(K)%MUCHINEED(1)*I_CNT, MPI_DOUBLE_PRECISION,          & !recvcount, recvtype
!      IEXBOUNDHIR(K)%PROCID, IEXBOUNDHIR(K)%PROCID,                    & !source, tag
!      MPI_COMM_WORLD,STATUS,IERROR                                     & !communicator, status, error
!   )
END DO

CALL MPI_WAITALL(n_requests, requests, MPI_STATUSES_IGNORE, ierror)





deallocate(requests)
!$OMP END MASTER
!$OMP BARRIER

END SUBROUTINE EXHBOUNDHIGHER_MOOD





SUBROUTINE EXHBOUNDHIGHER_dg(N)
!> @brief
!> This subroutine is communicating the boundary extrapolated values for the variables and their gradients
!> for the Gaussian quadrature points of direct-side neighbours between MPI processes 
IMPLICIT NONE
INTEGER,INTENT(IN)::N
INTEGER::I,J,K,L,M,O,P,Q,INEEDT,TNEEDT,INDL,TNDL,ICPUID,ITTT,IEX,IMULTI,K_CNT,nvar
INTEGER::ITEE,ITEEDUM,JK,JJK,JJK4,JJK12,IMULTI2,ICPE,JMNB,J76,J78,J79,J80,IMULTI3,I_CNT,cinout2
integer:: n_requests 
integer, dimension(:), allocatable:: requests
real::pr_t31,pr_t32,pr_t33,pr_t34,pr_t35,temp_prin,temp_prout
 cinout2=0
INDL=IEXCHANGER(1)%TOT
TNDL=IEXCHANGES(1)%TOT

pr_t31=zero
pr_t32=zero
pr_t33=zero
pr_t34=zero
pr_t35=zero
temp_prin=zero
temp_prout=zero



! 
!     if (statistics.eq.1)then
!     
!     !$OMP MASTER
!     pr_t31=MPI_Wtime()
! !     prace_t1=pr_t2-pr_t1
!     !$OMP END MASTER
!      
!     end if



if(indl .ne. tndl) then
   write (*, *) "exhbounhigher: INDL and TNDL are supposed to be equal; INDL=", INDL, "TNDL=", TNDL
   call MPI_ABORT(MPI_COMM_WORLD, 1, IERROR)
end if

IF (DIMENSIONA.EQ.3)THEN


IF( ITESTCASE.EQ.4)THEN
I_CNT=(nof_variables+TURBULENCEEQUATIONS+PASSIVESCALAR)+((4+TURBULENCEEQUATIONS+PASSIVESCALAR)*3)
ELSE

I_CNT=nof_variables
END IF

ELSE
IF( ITESTCASE.EQ.4)THEN
I_CNT=(nof_variables+TURBULENCEEQUATIONS+PASSIVESCALAR)+((3+TURBULENCEEQUATIONS+PASSIVESCALAR)*2)
ELSE

I_CNT=nof_variables
END IF
END IF


IF (ITESTCASE.LE.3) THEN
!$OMP DO SCHEDULE (STATIC)
    DO I=1,TNDL
        DO K=1,IEXCHANGES(I)%MUCHTHEYNEED(1)
    
            
                IEXBOUNDHIS(I)%FACESOL_dg(K,1:NOF_VARIABLES)=ILOCAL_RECON3(IEXCHANGES(I)%LOCALREF(K))%ULEFT_dg(1:NOF_VARIABLES,IEXCHANGEs(I)%SIDEtheyNEED(K),IEXCHANGES(I)%QTHEYNEED(k))
            

        END DO
    END DO
!$OMP END DO
END  IF


IF (ITESTCASE.EQ.4) THEN

IF (TURBULENCE.NE.1)THEN
!$OMP DO SCHEDULE (STATIC)
DO I=1,TNDL
DO K=1,IEXCHANGES(I)%MUCHTHEYNEED(1)
IEXBOUNDHIS(I)%FACESOL_dg(K,1:NOF_vARIABLES)=ILOCAL_RECON3(IEXCHANGES(I)%LOCALREF(K))%ULEFT_dg(1:NOF_vARIABLES,IEXCHANGEs(I)%SIDEtheyNEED(K),IEXCHANGES(I)%QTHEYNEED(k))

ITTT=0
DO IEX=1,NOF_VARIABLES-1
      DO nvar=1,DIMS
      ITTT=ITTT+1
		  IEXBOUNDHIS(I)%FACESOL_dg(K,NOF_vARIABLES+ITTT)=ILOCAL_RECON3(IEXCHANGES(I)%LOCALREF(K))%ULEFTV(NVAR,IEX,IEXCHANGEs(I)%SIDEtheyNEED(K),IEXCHANGES(I)%QTHEYNEED(k))

      END DO
END DO
END DO
END DO
!$OMP END DO

ELSE
!$OMP DO SCHEDULE (STATIC)
DO I=1,TNDL
DO K=1,IEXCHANGES(I)%MUCHTHEYNEED(1)
IEXBOUNDHIS(I)%FACESOL_dg(K,1:NOF_vARIABLES)=ILOCAL_RECON3(IEXCHANGES(I)%LOCALREF(K))%ULEFT_dg(1:NOF_vARIABLES,IEXCHANGEs(I)%SIDEtheyNEED(K),IEXCHANGES(I)%QTHEYNEED(k))
IEXBOUNDHIS(I)%FACESOL(K,NOF_vARIABLES+1:NOF_vARIABLES+TURBULENCEEQUATIONS+PASSIVESCALAR)=ILOCAL_RECON3(IEXCHANGES(I)%LOCALREF(K))%ULEFTTURB(1:TURBULENCEEQUATIONS+PASSIVESCALAR,IEXCHANGEs(I)%SIDEtheyNEED(K),IEXCHANGES(I)%QTHEYNEED(k))


ITTT=0
DO IEX=1,NOF_VARIABLES-1
      DO nvar=1,DIMS
      ITTT=ITTT+1
		  IEXBOUNDHIS(I)%FACESOL(K,NOF_vARIABLES+TURBULENCEEQUATIONS+PASSIVESCALAR+ITTT)=ILOCAL_RECON3(IEXCHANGES(I)%LOCALREF(K))%ULEFTV(NVAR,IEX,IEXCHANGEs(I)%SIDEtheyNEED(K),IEXCHANGES(I)%QTHEYNEED(k))
      END DO
END DO
DO IEX=1,TURBULENCEEQUATIONS+PASSIVESCALAR
      DO nvar=1,DIMS
      ITTT=ITTT+1
	IEXBOUNDHIS(I)%FACESOL(K,NOF_vARIABLES+TURBULENCEEQUATIONS+PASSIVESCALAR+ITTT)=ILOCAL_RECON3(IEXCHANGES(I)%LOCALREF(K))%ULEFTTURBV(NVAR,IEX,IEXCHANGEs(I)%SIDEtheyNEED(K),IEXCHANGES(I)%QTHEYNEED(k))
      END DO
END DO
END DO
END DO
!$OMP END DO

END IF
END  IF

!$OMP BARRIER


!-------------------FOR DEBUGGING ONLY -----------------------------------------!

!-------------------FOR DEBUGGING ONLY -----------------------------------------!

!$OMP MASTER
!CALL MPI_BARRIER(mpi_comm_world,ierror)

n_requests = 0
allocate(requests(2*indl))
requests(:)=0
ICPUID=N



!     if (statistics.eq.1)then
!     
!     !$OMP MASTER
!     pr_t32=MPI_Wtime()
! !     prace_t33=pr_t32-pr_t31
!     !$OMP END MASTER
!     
!     end if








DO K=1,INDL

   ! Search unique J such that (IEXBOUNDHIR(K)%PROCID .EQ. IEXBOUNDHIS(J)%PROCID)
   J = 1
   DO WHILE(IEXBOUNDHIR(K)%PROCID .NE. IEXBOUNDHIS(J)%PROCID)
      J = J + 1
   END DO

   ! non-blocking send
   n_requests = n_requests + 1
   CALL MPI_ISEND(                                                     &
      IEXBOUNDHIS(J)%FACESOL_dg(1:IEXCHANGES(J)%MUCHTHEYNEED(1),1:I_CNT), & !sendbuf
      IEXCHANGES(J)%MUCHTHEYNEED(1)*I_CNT, MPI_DOUBLE_PRECISION,       & !sendcount, sendtype
      IEXBOUNDHIS(J)%PROCID, 0,                                        & !destination, tag
      MPI_COMM_WORLD, requests(n_requests), ierror                     & !communicator, request handle, error
   )

   ! non-blocking receive
   n_requests = n_requests + 1
   CALL MPI_IRECV(                                                     &
      IEXBOUNDHIR(K)%FACESOL_dg(1:IEXCHANGER(K)%MUCHINEED(1),1:I_CNT),    & !recvbuf
      IEXCHANGER(K)%MUCHINEED(1)*I_CNT, MPI_DOUBLE_PRECISION,          & !recvcount, recvtype
      IEXBOUNDHIR(K)%PROCID, 0,                                        & !source, tag
      MPI_COMM_WORLD, requests(n_requests), ierror                     & !communicator, request handle, error
   )


END DO

CALL MPI_WAITALL(n_requests, requests, MPI_STATUSES_IGNORE, ierror)

! if (statistics.eq.1)then
!     
!    
!     pr_t33=MPI_Wtime()
! !     prace_t33=pr_t32-pr_t31
!         pr_t34=pr_t33-pr_t32
!         pr_t35=pr_t32-pr_t31
!         
! !       
! 
!     
!      
!     end if




deallocate(requests)
!$OMP END MASTER
!$OMP BARRIER

END SUBROUTINE EXHBOUNDHIGHER_dg








END MODULE COMMUNICATIONS
